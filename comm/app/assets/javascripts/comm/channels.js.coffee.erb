//= require comm/storage_controller

<% environment.context_class.instance_eval { include Rails.application.routes.url_helpers } %>
# Comm::Engine.routes.url_helpers

# @unsubscribe on client:
# https://github.com/faye/faye/issues/28
# server might publish unsubscibe even if client didn't send - but the client will reconnect(resubscribe) then.
# server does this because clients don't reliably disconnect and so server has timeout.
# reproduce when setting breakpoint in client and wait

# curl -X POST http://192.168.1.4:3005/comm -H 'Content-Type: application/json' -d '{"channel":"/system@0rg94cpmy","data":{"type":"handshake", "hello":"world"}}'
class window.Comm.Comm

  @_SINGLETON = null

  client = null
  channelCallBacksJSON = null
  systemReady = false

#
# 1) on starting up the faye-client requests a channel-key from system, f.ex: talk213enfn23r2n3
#    this is also a check for online state
# 2) TODO credentials
#
#    then everything goes over faye and server pubishes to all users associeated with 32432jnrrf43
#    *) server generates key and listens to that channel
#       - when client publishes server publishes to all external listeners
#       - server can push to client any time
#    whats that good for
# 2) send everything to rails-app and let her handle  publishing
#    @see fax-rails if railx can reduce listeners - even if possible - it's more complex
# 3) everything over faye
  constructor: (userId, channelCallBacksList, sysChannelEncKey, systemCallBack) ->
    Comm._SINGLETON = this
    @_user_id = userId
    @_storageController = window.Comm.StorageController.instance()

    client = new Faye.Client(document.location.origin+'/comm')
    # rather for debugging
    client.addExtension({ incoming: Comm._incoming, outgoing: Comm._outgoing })

    # map callbacks to channels
    Comm.channelCallBacksJSON = new Object()
    Comm.channelCallBacksJSON['system'] = { callback: systemCallBack, channel_enc_key: sysChannelEncKey }
    for pair in channelCallBacksList
      Comm.channelCallBacksJSON[pair[0].substr(1)] = { callback: pair[1], channel_enc_key: pair[2] }

    if (sysChannelEncKey == null)
      this.register(@_user_id)
    else
      Comm.initSystemContext {sys_channel_enc_key: sysChannelEncKey}

  register: (userId) ->
    data = { _method: 'put',\
             user_id: userId }
    $.ajax
      type: 'POST'
      dataType: 'json'
      url: '<%= comm_register_path %>'
      data: data
    .done (msg) ->
        Comm.initSystemContext msg
    .fail (jqXHR, textStatus) ->
        alert('TODO: handle registration failure...')

  send: (channel, message) ->
    # 1) client wants to publish before register-ajax-response set the enc_key
    #    1.1: store request and send after register (local storage)
    # 2) the same goes for requests when client is offline
    unless Comm.channelCallBacksJSON[channel.substr(1)] == null or !systemReady
      channelPath = channel
      unless window.VoyageX.USE_GLOBAL_SUBSCRIBE
        channelPath += VoyageX.PEER_CHANNEL_PREFIX+Comm.channelCallBacksJSON[channel.substr(1)].channel_enc_key
      client.publish(channelPath, message)
    else
      if (Modernizr.localstorage)
        console.log('caching publish to '+channel)
        # later send: @_storageController.pop('comm.publish')
        cacheEntry = { channel: channel, message: message }
        @_storageController.addToList('comm.publish', 'push', cacheEntry)
      else
        alert('This Browser Doesn\'t Support Local Storage so This Message will be lost if you quit the Browser')

  @resetSystemContext: (userId) ->
    Comm.instance()._user_id = userId
    Comm.channelCallBacksJSON.system.channel_enc_key = null 
    for channel in Object.keys(Comm.channelCallBacksJSON)
      Comm.channelCallBacksJSON[channel].channel_enc_key = null
    Comm.instance().register userId

  @initSystemContext: (response) ->
    Comm.channelCallBacksJSON.system.channel_enc_key = response.sys_channel_enc_key
    channelPath = '/system'
    unless window.VoyageX.USE_GLOBAL_SUBSCRIBE 
      channelPath += VoyageX.PEER_CHANNEL_PREFIX+response.sys_channel_enc_key
    Comm.subscribeTo channelPath, Comm._systemSubscriptionListener
    # this is done via serverside publishing to systemchannel 
    # @see ChannelsController - system:monitor
    # @see Comm.subscribeTo - subscribe-callback
    # Comm.initChannelContexts response, Comm.channelCallBacksJSON

  @initChannelContexts: (initParams, channelCallBacks) ->
    for channel in Object.keys(channelCallBacks)
      if channel == 'system'
        continue
      channelCallBacks[channel].channel_enc_key = initParams.channel_enc_key
      channelPath = '/'+channel
      unless window.VoyageX.USE_GLOBAL_SUBSCRIBE 
        channelPath += VoyageX.PEER_CHANNEL_PREFIX+initParams.channel_enc_key
      # subscribe to my own events - fails because of race-conditions
      #Comm.unsubscribeFrom channelPath
      Comm.subscribeTo channelPath, channelCallBacks[channel].callback

  @subscribeTo: (channel, callBack) ->
    # https://github.com/faye/faye/blob/master/javascript/protocol/client.js
    unless client._channels.hasSubscription(channel)
      if channel.match(/^\/?system/)
        client.subscribe channel, Comm._systemSubscriptionListener
      else
        client.subscribe channel, callBack
    else
      console.log('client already subscribed to channel '+channel)

  @unsubscribeFrom: (channelPath, signOut = false) ->
    if channelPath.match(/^\/?system/) and not signOut
      return
    # https://github.com/faye/faye/blob/master/javascript/protocol/client.js
    if client._channels.hasSubscription(channelPath)
      # you only can unsubscribe with passing the subscription-callback(=listener)
      # otherwise faye will not perform unsubscription
      # http://faye.jcoglan.com/architecture.html #Client
      # FayeClient - channel.unbind
      if channelPath.match(/^\/?system/)
        client.unsubscribe channelPath, Comm._systemSubscriptionListener
      else
        i = channelPath.indexOf(VoyageX.PEER_CHANNEL_PREFIX)
        channel = (if i == -1 then channelPath else channelPath.substr(0, i)).substr(1)
        client.unsubscribe channelPath, Comm.channelCallBacksJSON[channel].callback
    else
      console.log('client was not subscribed to channel '+channelPath)

  @instance: () ->
    @_SINGLETON

  @_systemSubscriptionListener: (message) ->
    if message.type == 'ready_notification'
      Comm.initChannelContexts message, Comm.channelCallBacksJSON
      systemReady = true
      while (cacheEntry = Comm.instance()._storageController.pop('comm.publish'))
        console.log('sending cached-publish to '+cacheEntry.channel)
        Comm.instance().send cacheEntry.channel, cacheEntry.message
    # since unsubscribed client will not receive anymore - but server will send this on next subscription
    # before ready_notification
    # if client disconnects by itself, then:
    # ---------- ClientExtension - outgoing Object {channel: "/meta/disconnect", clientId: "aems9kiq4i4gedw80tgjqblw8qytfyu", id: "c"}
    # ++++++++++ ClientExtension - incoming Object {id: "c", clientId: "aems9kiq4i4gedw80tgjqblw8qytfyu", channel: "/meta/disconnect", successful: true}
    # on serverside it looks the same as timeout-unsubscribe
    else if message.type == 'unsubscribed_notification'
        console.log('_systemSubscriptionListener: client '+message.old_client_id+' unsubscribed '+message.seconds_ago+' seconds ago ... (probably timedout/disconnected by server)')
        return null
    Comm.channelCallBacksJSON.system.callback message

  @_incoming: (message, callback) ->
      #console.log('++++++++++ ClientExtension - incoming', message);
      callback message
  
  @_outgoing: (message, callback) ->
      #console.log('---------- ClientExtension - outgoing', message);
      callback message
