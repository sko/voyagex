class window.Comm.StorageController

  @_SINGLETON = null
  @_FS = null

  constructor: (fsInitCB) ->
    unless Modernizr.localstorage
      alert('This Browser Doesn\'t Support Local Storage.')
    if StorageController._SINGLETON != null
      alert('ERROR: StorageController is Singleton')
      return null
    StorageController._SINGLETON = this
    @_jsonObjects = {}
    @_tileDB = {}
    @_tileMeta = null
    @_tileLoadQueue = {}
    @_tileImageContentType = 'image/webp'
    @_grantedBytes = 0
    @_dirReaders = {}
    requestedBytes = Math.pow(2, 26) # 64MB
    try
      fileAPISupport = `navigator.webkitPersistentStorage !== undefined`
    catch error
      fileAPISupport = false
    console.log('StorageController.constructor - fileAPISupport = '+fileAPISupport)
    if fileAPISupport
      window.webkitStorageInfo.queryUsageAndQuota(webkitStorageInfo.PERSISTENT, 
          (used, remaining) ->
              console.log("Used quota: " + used + ", remaining quota: " + remaining)
          , (e) ->
              console.log('Error', e)
          )
      # @deprecated
      #window.webkitStorageInfo.queryUsageAndQuota(webkitStorageInfo.PERSISTENT,  (used, remaining) ->
      #window.webkitStorageInfo.requestQuota(webkitStorageInfo.PERSISTENT, requestedBytes, (grantedBytes) ->
      navigator.webkitPersistentStorage.requestQuota(requestedBytes, (grantedBytes) ->
          #window.webkitRequestFileSystem(PERSISTENT, grantedBytes, StorageController.onInitFs, StorageController.onFsError)
          # @deprecated
          window.webkitRequestFileSystem(webkitStorageInfo.PERSISTENT, grantedBytes, (fs) ->
                console.log('filesystem zugang')
                sC = StorageController.instance()
                sC._dirReaders = { parent: null, path: '/', entry: fs.root, reader: fs.root.createReader(), entries: {} }
                StorageController._FS = fs
                fsInitCB false
            ,
            (e) ->
                console.log('kein filesystem zugang')
                fsInitCB true
            )
        , (e) ->
            console.log('Error', e); 
            fsInitCB true
        )
    else
      fsInitCB true

  @storeKey: (xYZ) ->
    xYZ[2]+'/'+xYZ[0]+'/'+xYZ[1]
  
  @isFileBased: () ->
    StorageController._FS?
    #false

  _removeDirectory: (dirName) ->
    @_dirReaders.entry.getDirectory(dirName, {}, (dirEntry) ->
            dirEntry.removeRecursively(() ->
                console.log('removing directory '+dirName+' ...')
              , (e) ->
                console.log('error when removing directory '+dirName+': ', e)
              )
          , (e) ->
              console.log('error when removing directory '+dirName+': ', e)
          )

  clearCache: () ->
    this.delete('tiles')
    for dirName in VoyageX.MapControl.instance()._offlineZooms
      this._removeDirectory dirName

  _saveFile: (xYZ, fileIdx, dirReader, data) ->
    sC = StorageController.instance()
    path = dirReader.path+'/'+xYZ[fileIdx]
    dirReader.entry.getFile(xYZ[fileIdx], {}, (fileEntry) ->
#        unless dirReader.entries[xYZ[fileIdx]]?
#          dirReader.entries[xYZ[fileIdx]] = { parent: dirReader, path: path, entry: fileEntry, reader: fileEntry.createReader(), entries: {} }
        sC._storeTileAsFile xYZ, dirReader, null
      , (e) ->
        if (e.code == FileError.NOT_FOUND_ERR) 
          dirReader.entry.getFile(xYZ[fileIdx], {create: true}, (fileEntry) ->
                fileEntry.createWriter((fileWriter) ->
                  fileWriter.onwriteend = (e) ->
                      console.log('Write completed.')
                      storeKey = StorageController.storeKey(xYZ)
                      delete sC._tileLoadQueue[storeKey]
                      tileMeta = localStorage.getItem 'comm.tiles.tileMeta'
                      if tileMeta == null
                        sC._tileMeta = { tilesByteSize: 0, numTiles: 0 }
                      else
                        sC._tileMeta = eval("(" + tileMeta + ")")
                      #sC._tileDB[storeKey] = data.properties.data
                      sC._tileMeta.numTiles = sC._tileMeta.numTiles+1
                      sC._tileMeta.tilesByteSize = sC._tileMeta.tilesByteSize+data.properties.data.size
                      localStorage.setItem 'comm.tiles.tileMeta', JSON.stringify(sC._tileMeta)
                      showCacheStats(sC._tileMeta.numTiles, sC._tileMeta.tilesByteSize)
                  fileWriter.onerror = (e) ->
                      console.log('Write failed: ' + e.toString())
                      delete sC._tileLoadQueue[StorageController.storeKey(xYZ)]
                  console.log('saving file: '+path)
                  fileWriter.write(new Blob([data.properties.data], {type: sC._tileImageContentType}))
                  # text-files
                  #fileWriter.write(data.properties.data)
                , (e) ->
                    console.log('_saveFile - '+e+' when trying to WRITE file '+path)
                )
            , (e) ->
                console.log('_saveFile - '+e+' when trying to SAVE file '+path)
            )
        else
          console.log('_saveFile - '+e+' when trying to READ file '+path)
          sC._storeTileAsFile xYZ, dirReader, data, nextDirIdx
      )

  _getDirectory: (xYZ, nextDirIdx, dirReader, data, firstCall = true) ->
    sC = StorageController.instance()
    path = (if dirReader.parent == null then '' else dirReader.path)+'/'+xYZ[nextDirIdx]
    dirReader.entry.getDirectory(xYZ[nextDirIdx], {}, (fileEntry) ->
        #console.log('found directory: '+path)
        unless dirReader.entries[xYZ[nextDirIdx]]?
          dirReader.entries[xYZ[nextDirIdx]] = { parent: dirReader, path: path, entry: fileEntry, reader: fileEntry.createReader(), entries: {} }
        sC._storeTileAsFile xYZ, dirReader.entries[xYZ[nextDirIdx]], data
      , (e) ->
        if (e.code == FileError.NOT_FOUND_ERR) 
          console.log('creating directory: '+path)
          dirReader.entry.getDirectory(xYZ[nextDirIdx], {create: true, exclusive: true}, (fileEntry) ->
              unless dirReader.entries[xYZ[nextDirIdx]]?
                dirReader.entries[xYZ[nextDirIdx]] = { parent: dirReader, path: path, entry: fileEntry, reader: fileEntry.createReader(), entries: {} }
              sC._storeTileAsFile xYZ, dirReader.entries[xYZ[nextDirIdx]], data
            , (e) ->
              if (e.code == FileError.NOT_FOUND_ERR) 
                console.log('_getDirectory - No such file: '+path)
              else
                # it's likely that directory has been created by other request
                if firstCall
                  #console.log('_getDirectory - '+e+' when trying to CREATE directory / trying one more READ: '+path)
                  return sC._getDirectory xYZ, nextDirIdx, dirReader, data, false
                else
                  console.log('_getDirectory - '+e+' when trying to CREATE directory '+path)
              sC._storeTileAsFile xYZ, dirReader, data, nextDirIdx
            )
        else
          console.log('_getDirectory - '+e+' when trying to READ directory '+path)
          sC._storeTileAsFile xYZ, dirReader, data, nextDirIdx
      )

  _storeTileAsFile: (xYZ, parentDirReader, data, failedIndex = -1) ->
    if failedIndex != -1
      console.log('error: failedIndex = '+failedIndex+' for '+xYZ)
    else if parentDirReader == null
      this._getDirectory xYZ, 2, @_dirReaders, data
    else if parentDirReader.parent.parent == null
      this._getDirectory xYZ, 0, parentDirReader, data
    else if data != null
      this._saveFile xYZ, 1, parentDirReader, data
  
  _getTileFile: (xYZ, prefetchMode, deferredModeParams, firstCall = true) ->
    path = '/'+xYZ[2]+'/'+xYZ[0]+'/'+xYZ[1]
    @_dirReaders.entry.getFile(path, {}, (fileEntry) ->
        console.log('found file: '+path)
        # if binary:
        deferredModeParams.deferred.resolve fileEntry.toURL(StorageController.instance()._tileImageContentType)
#        # if text (base64):
#        fileEntry.file (file) ->
#            #@_dirReaders.entries[xYZ[2]].entries[xYZ[0].reader
#            reader = new FileReader()
#            reader.onabort = (e) ->
#                console.log('aborted '+path+": "+e)
#            reader.onerror = (e) ->
#                console.log('failed '+path+": "+e)
#            reader.onload = (e) ->
#                if this.result == ''
#                  console.log('bad read on '+path)
#                deferredModeParams.deferred.resolve this.result
#            reader.readAsText(file)
#            #reader.readAsDataURL(file, StorageController.instance()._tileImageContentType)
      , (e) ->
        if (e.code == FileError.NOT_FOUND_ERR) 
          if firstCall
            # check one more time if other thread stored file
            #console.log('_getTileFile - no such file / trying one more READ: '+path)
            return StorageController.instance()._getTileFile xYZ, prefetchMode, deferredModeParams, false
          else
            console.log('_getTileFile - no such file: '+path)
        else
          console.log('error: '+e+' for '+path)
        #deferredModeParams.deferred.resolve deferredModeParams.tileUrlCB(deferredModeParams.mC, deferredModeParams.view, deferredModeParams)
        #if deferredModeParams.callBack
        #  deferredModeParams.callBack = false
        #  # TODO
        #if xYZ[2] == deferredModeParams.view.zoom
        if prefetchMode == 0
          # one mor check for asynchronous request
          loadQueueEntry = StorageController.instance()._tileLoadQueue[StorageController.storeKey(xYZ)]
          unless loadQueueEntry? && (!loadQueueEntry.storeFile)
            #loadQueueEntry.storeFile = false
            deferredModeParams.tileUrlCB(deferredModeParams.mC, deferredModeParams.view, deferredModeParams)
            deferredModeParams.deferred.resolve deferredModeParams.tileUrl
          else
            console.log('TODO: _getTileFile - if this is logged then loadQueueEntry-check is necessary')
        else
          if prefetchMode == 1
            VoyageX.MapControl.loadAndPrefetch deferredModeParams.mC, xYZ, deferredModeParams.view.subdomain, deferredModeParams
          else
            deferredModeParams.mC._loadReadyImage deferredModeParams.tileUrl, xYZ
      )

  _checkedTileLoadQueue: (xYZ, checkStoreFile, callback) ->
    storeKey = StorageController.storeKey(xYZ)
    stored = @_tileLoadQueue[storeKey]
    if stored?
      if checkStoreFile && stored.storeFile
        promise = callback(stored)
        stored.storeFile = false
      #console.log('getTile - stored in queue: '+storeKey); 
      #return this._result storeKey, stored
      return stored.promise
    queueEntry = { promise: null, storeFile: true }
    callback(queueEntry)
    # @see storeTile
    @_tileLoadQueue[storeKey] = queueEntry

  loadAndPrefetchTile: (prefetchParams) ->
    sC = this
    this._checkedTileLoadQueue prefetchParams.xYZ, true, (queueEntry) ->
        sC._getTileFile prefetchParams.xYZ, 1, prefetchParams
        prefetchParams.promise = prefetchParams.deferred.promise()
        queueEntry.promise = prefetchParams.promise

  prefetchTile: (prefetchParams) ->
    sC = this
    this._checkedTileLoadQueue prefetchParams.xYZ, true, (queueEntry) ->
        sC._getTileFile prefetchParams.xYZ, 2, prefetchParams
        prefetchParams.promise = prefetchParams.deferred.promise()
        queueEntry.promise = prefetchParams.promise
        queueEntry.storeFile = false

  storeTile: (xYZ, data, promise = null) ->
    if promise != null
      # @see getTile
      unless @_tileLoadQueue[StorageController.storeKey(xYZ)]?
        @_tileLoadQueue[StorageController.storeKey(xYZ)] = { promise: promise, storeFile: true }
      else
        console.log('storeTile - promise for '+StorageController.storeKey(xYZ)+' already stored in queue ...')
      return promise

    if StorageController.isFileBased()
      this._storeTileAsFile xYZ, null, data
    else
      tileMeta = localStorage.getItem 'comm.tiles.tileMeta'
      if tileMeta == null
        @_tileMeta = { tilesByteSize: 0, numTiles: 0 }
      else
        @_tileMeta = eval("(" + tileMeta + ")")

      storeKey = 'comm.tiles.'+data.properties.id
      stored = localStorage.getItem storeKey
      if stored == null
#        tileStoreZ = {}
#        yEntry = {}
#        yEntry[xYZ[1]] = data
#        tileStoreZ[xYZ[0]] = [yEntry]
#        localStorage.setItem 'comm.tiles.'+xYZ[2], JSON.stringify(listEntries)
        delete @_tileLoadQueue[StorageController.storeKey(xYZ)]
        localStorage.setItem storeKey, data.properties.data
        @_tileDB[storeKey] = data.properties.data
        @_tileMeta.numTiles = @_tileMeta.numTiles+1
        @_tileMeta.tilesByteSize = @_tileMeta.tilesByteSize+data.properties.data.length

      localStorage.setItem 'comm.tiles.tileMeta', JSON.stringify(@_tileMeta)
  
  getTile: (xYZ, deferredModeParams = null) ->
    if StorageController.isFileBased()
      sC = this
      this._checkedTileLoadQueue xYZ, false, (queueEntry) ->
          console.log('getTile - '+StorageController.storeKey(xYZ)); 
          # for file-API works asynchronously we have to always promise file - given that tile-loadimg-logic
          # is also handled here
          #deferredModeParams.deferred = $.Deferred()
          sC._getTileFile xYZ, 0, deferredModeParams
          deferredModeParams.promise = deferredModeParams.deferred.promise()
          queueEntry.promise = deferredModeParams.promise
      null
# this was required in mixed mode (localStorage/file) when fs was not ready but images already started load
#    else if deferredModeParams != null
#      #deferredModeParams.tileUrlCB(deferredModeParams.mC, deferredModeParams.view, deferredModeParams)
#      deferredModeParams.deferred.resolve deferredModeParams.tileUrlCB(deferredModeParams.mC, deferredModeParams.view, deferredModeParams)
    else
      storeKey = StorageController.storeKey(xYZ)
      stored = @_tileLoadQueue[storeKey]
      if stored?
        #console.log('getTile - stored in queue: '+storeKey); 
        #return this._result storeKey, stored
        return stored.promise
      stored = @_tileDB['comm.tiles.'+storeKey]
      unless stored?
#        stored = @_tileLoadQueue[storeKey]
#        unless stored?
          stored = localStorage.getItem 'comm.tiles.'+storeKey
          @_tileDB['comm.tiles.'+storeKey] = stored
#        else
#          console.log('stored in queue: '+storeKey); 
      # for backward-compatibility
      if stored?
         # sko_13122014 @oldscool: this._result storeKey, stored
         stored
      else
        null

  storeImage: (xYZ, tileDataUrl) ->
    storeKey = StorageController.storeKey(xYZ)
    geoJSON = {
        properties: {
            id: storeKey,
            data: tileDataUrl,
            created_at: Date.now()
          },
        geometry: {
            coordinates: [-1.0, -1.0] # TODO
          }
      }
    console.log 'caching tile: '+storeKey
    this.storeTile xYZ, geoJSON

  # reserved listKeys:
  # push: creates/uses an array for entries stored with storeKey
  # if an array is defined for a storeKey then there can't be any other objects defined aside (@see this.pop())
  addToList: (storeKey, listKey, data) ->
    stored = localStorage.getItem(storeKey)
    if stored == null
      listEntries = {}
      if listKey == 'push'
        #listEntries[listKey] = [data]
        # using push will return push-function on anArray['push']
        listEntries['sc_list'] = [data]
        #listEntries[listKey] = { push: [data] }
      else
        @_jsonObjects[storeKey] = listEntries
        listEntries[listKey] = data
      localStorage.setItem(storeKey, JSON.stringify(listEntries))
    else
      if stored.trim().match(/^\[/) == null
        alert('expected Object/List - change of EntryType not implemented')
      else
        storedJSON = @_jsonObjects[storeKey]
        unless storedJSON?
          storedJSON = eval("(" + stored + ")")
          @_jsonObjects[storeKey] = storedJSON
        if listKey == 'push'
        ##storedJSON[listKey].push(data) # LIFO with push
         #storedJSON[listKey].splice(0, 0, data) # FIFO with push
          storedJSON['sc_list'].splice(0, 0, data) # FIFO with push
        else
          storedJSON[listKey] = data
        localStorage.setItem(storeKey, JSON.stringify(storedJSON));

  get: (storeKey, listKey) ->
    # FIXME @_jsonObjects is an internal cache-object and should not be exposed to concurrent access
    #       readonly but 'live' copy -> wrapper object! with methods getItem() for [] and real object 
    @_jsonObjects[storeKey] || eval("(" + localStorage.getItem(storeKey) + ")")

  getNumElements: (storeKey, listKey = null) ->
#    # TODO listKey != null, id might not be available
#    if @_jsonObjects[storeKey]?
#      Object.keys(@_jsonObjects[storeKey]).length
#    else
#      stored = localStorage.getItem(storeKey)
#      if stored != null then (stored.match(/("id":)/g)||[]).length else 0
#    #stored = localStorage.getItem(storeKey)
#    #(if stored != null then Math.round(localStorage[storeKey].length/1024) else 0)+' kB'
    tileMeta = localStorage.getItem 'comm.tiles.tileMeta'
    if tileMeta == null
      0
    else
      @_tileMeta = eval("(" + tileMeta + ")").numTiles

  getByteSize: (storeKey, listKey = null) ->
    # TODO listKey != null
#    stored = localStorage.getItem(storeKey)
#    if stored != null then stored.length else 0
    tileMeta = localStorage.getItem 'comm.tiles.tileMeta'
    if tileMeta == null
      0
    else
      @_tileMeta = eval("(" + tileMeta + ")").tilesByteSize

  delete: (storeKey, listKey = null) ->
    # TODO listKey != null
    window.localStorage.clear()
    @_tileDB = null
    @_tileDB = {}
    @_tileMeta = { tilesByteSize: 0, numTiles: 0 }
    localStorage.removeItem 'comm.tiles.tileMeta'

    localStorage.removeItem('tiles')
    if @_jsonObjects[storeKey]?
      @_jsonObjects[storeKey] = null

  # expects an array stored with 'push' as listKey in storeKey-entry
  # TODO cache list-object as well like @_jsonObjects
  pop: (storeKey) ->
    stored = localStorage.getItem(storeKey)
    unless stored == null
      storedJSON = eval("(" + stored + ")")
     #listEntries = storedJSON['push']
      listEntries = storedJSON['sc_list']
      if listEntries?
        listEntry = listEntries.pop()
        if listEntries.length >= 1
          localStorage.setItem(storeKey, JSON.stringify(listEntries));
        else
          localStorage.removeItem(storeKey)
        listEntry
    else
      null

  @instance: () ->
    @_SINGLETON

#
# provides readonly-'live'-access to storage-entry
#
class Comm.StorageEntryWrapper
  
  constructor: (jsonObject) ->
    @_jsonObject = jsonObject

  getItem: (key) ->
    @_jsonObject[key]