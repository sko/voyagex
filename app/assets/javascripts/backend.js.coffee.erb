<% environment.context_class.instance_eval { include Rails.application.routes.url_helpers } %>
# Comm::Engine.routes.url_helpers

if window.VoyageX?
  window.VoyageX.Backend = {}
else
  window.VoyageX = { Backend: {} }

class window.VoyageX.Backend
  
  @_SINGLETON = null
  @_PING_INTERVAL_MILLIS = 10000
  @_PING_CHECK_DELAY_MILLIS = 3000
  @_POS_QUERY_INTERVAL_MILLIS = 20000
  @_POS_QUERY_TIMEOUT_MILLIS = 60000

  constructor: (forceOffline = false) ->
    Backend._SINGLETON = this
    @_state = { online: !forceOffline, pingActive: false, pingCount: 0, pingKey: -1, forceOffline: forceOffline }
    #setTimeout "VoyageX.Backend.instance().pingBackend()", 3000
    #Backend.instance().pingBackend()

  commConnStateCB: (online) ->
    if online
      VoyageX.Backend.instance()._state.pingActive &&= false
      unless APP._online
        APP.setOnline()
    else
      unless VoyageX.Backend.instance()._state.pingActive
        VoyageX.Backend.instance().pingBackend() # disable in development mode when binding pry

  _checkPingResponse: (pingKey) ->
    if Backend.instance()._state.pingKey != pingKey
      #console.log 'Backend - _checkPingResponse: pingKey = '+pingKey
      Backend.instance()._state.pingKey = pingKey
      setTimeout "VoyageX.Backend.instance().pingBackend()", Backend._PING_INTERVAL_MILLIS

  # backend needs it's own ping because app can be online when backend is down.
  pingBackend: (successCB = null) ->
    @_state.pingActive ||= true
    pingKey = Math.round(Math.random() * 100000)
    $.ajax
      type: 'GET'
      url: '<%= comm_ping_path(key: ':key') %>'.replace(/:key/, pingKey)
      dataType: 'json'
    .done (msg) ->
        Backend.instance()._state.pingKey = msg.ping_key
        Backend.instance()._state.online = true
        unless APP._online
          APP.setOnline()
        if successCB?
          successCB()
        Backend.instance()._state.pingActive &&= (!APP._comm.isOnline())
        if Backend.instance()._state.pingActive
          setTimeout "VoyageX.Backend.instance().pingBackend()", Backend._PING_INTERVAL_MILLIS
    .fail (jqXHR, textStatus) ->
        Backend.instance()._state.online = false
        if APP._online
          APP.setOffline()
        #Backend.instance()._state.pingActive &&= (!APP._comm.isOnline())
        if Backend.instance()._state.pingActive
          setTimeout 'VoyageX.Backend.instance()._checkPingResponse('+pingKey+')', Backend._PING_CHECK_DELAY_MILLIS

  # faye client takes some time to start up while backend already online
  # first call might still 
  isOnline: () ->
    online = @_state.online || APP._comm.isOnline()
    if APP._comm.isOnline()
      @_state.pingActive &&= false
    else
      unless @_state.pingActive
        # assume backend is down when faye is down.
        online = @_state.online = false
        # also check Comm.Comm - constructor
        unless @_state.forceOffline
          this.pingBackend()
    online

  register: (callback) ->
    data = { _method: 'put' }
    $.ajax
      type: 'POST'
      dataType: 'json'
      url: '<%= comm_register_path %>'
      data: data
    .done (msg) ->
        callback msg
        # curU = APP.user()
        # curU.peerPort = { channel_enc_key: msg.channel_enc_key,\
        #                   sys_channel_enc_key: msg.sys_channel_enc_key }
        # APP.storage().saveCurrentUser curU
        # Comm.Comm.initSystemContext msg.sys_channel_enc_key
    .fail (jqXHR, textStatus) ->
        alert('TODO: handle registration failure...')

  @instance: () ->
    Backend._SINGLETON

