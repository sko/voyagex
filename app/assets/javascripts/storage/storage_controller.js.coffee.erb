//= require storage/file_utils

# window.open("data:text/json," + JSON.stringify(APP.storage().getUser(264)), "_v_x_json")
class window.Comm.StorageController

  @_SINGLETON = null
  #@_FS = null

  constructor: (fsInitCB) ->
    unless Modernizr.localstorage
      alert('This Browser Doesn\'t Support Local Storage.')
    if StorageController._SINGLETON != null
      alert('ERROR: StorageController is Singleton')
      return null
    StorageController._SINGLETON = this
    @_uploadQ = new Comm.UploadQ()
    @_maxNumChatBCChatMsgs = 10
    @_maxNumChatP2PChatMsgs = 10
    @_jsonObjects = {}
    @_tileDB = {}
    @_tileMeta = null
    #@_tileLoadQueue = {}
    #@_tileImageContentType = 'image/webp'
    @_attachmentMeta = null
    @_fotoMeta = null
    #@_storedFilesAreBase64 = false
    #@_grantedBytes = 0
    #@_dirReaders = {}
    requestedBytes = Math.pow(2, 26) # 64MB
    @_fileUtils = new Comm.FileUtils requestedBytes, 'image/webp', false, fsInitCB

  @tileKey: (xYZ) ->
    xYZ[2]+'/'+xYZ[0]+'/'+xYZ[1]
  
  @poiKey: (poi) ->
    'comm.poi.'+poi.id
  
  @poiNoteAttachmentKey: (poiNote) ->
    'comm.poiNoteAttachment.'+poiNote.id
  
  @userPhotoKey: (user) ->
    'comm.userPhoto.'+user.id

  @uploadQueueKey: (storePath) ->
    storePath[0]+'/'+storePath[1]

  getLocation: (locationId) ->
    storeKey = 'comm.locations'
    locations = JSON.parse(localStorage.getItem(storeKey))
    if locations?
      location = locations[locationId]
      if location
        if locations.pois?
          poi = locations.pois[locationId]
          if poi?
            location.poiId = poi.id
        if locations.bookmarks?
          bookmark = locations.bookmarks[locationId]
          if bookmark?
            location.bookmark = bookmark
        location.id = locationId
      location
    else
      null
  
  # TODO - check for nearby-location
  saveLocation: (location, flags = {}, locations = null) ->
    storeKey = 'comm.locations'
    unless locations?
      locations = JSON.parse(localStorage.getItem(storeKey))
    unless locations
      locations = {}
    # decimal-scale: 7
    locations[location.id] = { lat: Math.round(location.lat*10000000)/10000000,\
                               lng: Math.round(location.lng*10000000)/10000000,\
                               address: location.address}
    if flags.homeBase?
      locations.homeBase = location.id
    if flags.poi?
      unless locations.pois?
        locations.pois = {}
      unless locations.pois[location.id]?
        locations.pois[location.id] = flags.poi
    localStorage.setItem storeKey, JSON.stringify(locations)
    location
  
  # after q-upload 
  resetLocation: (oldLocation, newLocation, newPoi = null) ->
    storeKey = 'comm.locations'
    locations = JSON.parse(localStorage.getItem(storeKey))
    flags = {}
    if locations.homeBase? && locations.homeBase == oldLocation.id
      flags.homeBase = true
    if newPoi?
      flags.poi = { id: newPoi.id }
    delete locations[oldLocation.id]
    if locations.pois? && locations.pois[oldLocation.id]?
      delete locations.pois[oldLocation.id]
    this.saveLocation newLocation, flags, locations
  
  getBookmark: (locationId) ->
    storeKey = 'comm.locations'
    locations = JSON.parse(localStorage.getItem(storeKey))
    if locations.bookmarks?
      bookmark = locations.bookmarks[locationId]
      if bookmark?
        bookmark.location = locations[locationId]
        bookmark.location.id = locationId
      bookmark
    else
      null

  bookmark: (locationId, text = null) ->
    storeKey = 'comm.locations'
    locations = JSON.parse(localStorage.getItem(storeKey))
    location = locations[locationId]
    #bookmark = {}
    # only bookmark existing locations
    if location?
      if locations.bookmarks?
        bookmark = locations.bookmarks[locationId]
        if bookmark?
          if text?
            bookmark.text = text
          bookmark.updatedAt = new Date().getTime()
          localStorage.setItem storeKey, JSON.stringify(locations)
        else
          bookmark = if text? then {updatedAt: new Date().getTime(), text: text} else {updatedAt: new Date().getTime()}
          locations.bookmarks[locationId] = bookmark
          localStorage.setItem storeKey, JSON.stringify(locations)
      else
        locations.bookmarks = {}
        bookmark = if text? then {updatedAt: new Date().getTime(), text: text} else {updatedAt: new Date().getTime()}
        locations.bookmarks[locationId] = bookmark
        localStorage.setItem storeKey, JSON.stringify(locations)
      # setup return-value
      location.id = locationId
      location.bookmark = bookmark
      if locations.pois? && locations.pois[locationId]?
        storeKey = StorageController.poiKey locations.pois[locationId]
        location.poi = this.get storeKey
    #bookmark
    location
  
  bookmarks: (callback = null) ->
    storeKey = 'comm.locations'
    locations = JSON.parse(localStorage.getItem(storeKey))
    #locations = this.get 'comm.locations'
    if locations.bookmarks?
      bookmarks = []
      for locationId in Object.keys(locations.bookmarks)
        if callback?
          if callback(locations, locations.bookmarks[locationId])
            bookmarks = []
            break
        bookmark = locations.bookmarks[locationId]
        bookmark.location = locations[locationId]
        bookmark.location.id = locationId
        if locations.pois? && locations.pois[locationId]?
          storeKey = StorageController.poiKey locations.pois[locationId].id
          bookmark.location.poi = this.get storeKey
        bookmarks.push bookmark
      bookmarks
    else
      []
  
  pois: (searchBounds, callback = null) ->
    storeKey = 'comm.locations'
    locations = JSON.parse(localStorage.getItem(storeKey))
    #locations = this.get 'comm.locations'
    if locations.pois?
      pois = []
      for locationId in Object.keys(locations.pois)
        location = locations[locationId]
        if withinSearchBounds(location.lat, location.lng, searchBounds)
          poiKey = StorageController.poiKey {id: locations.pois[locationId].id}
          if callback?
            if callback(locations, locations[locationId], locations.pois[locationId].id)
              pois = []
              break
          else
            #poi = StorageController.instance().get poiKey
            poi = JSON.parse(localStorage.getItem(poiKey))
            poi.lat = location.lat
            poi.lng = location.lng
            poi.address = location.address
            pois.push poi
      pois
    else
      []

  saveNote: (type, id, text) ->
    if type == 'peer'
      this.saveUser(this.getUser(id), {note: text})
    else
      this.bookmark id, text
      #bookmarks (locations, locationBookmark) ->
  
  getUser: (userId) ->
    storeKey = 'comm.users'
    users = JSON.parse(localStorage.getItem(storeKey))
    user = if users? then users[userId] else null
    if user?
      user.id = userId
      if users.peers? && (peer = users.peers[userId])?
        user.peerPort = peer.peerPort
      #delete user.chat
    user
  
  # a user ist created from scratch to avoid temporary attributes from being saved
  # all unkodified attributes will be saved -> xUser
  saveUser: (user, flags = {}) ->
    storeKey = 'comm.users'
    users = JSON.parse(localStorage.getItem(storeKey))
    unless users
      users = {}
    xUser = users[user.id]
    unless xUser?
      xUser = {}
    users[user.id] = {username: user.username}
    delete xUser.username
    if flags.peerPort?
      unless users.peers?
        users.peers = {}
      unless users.peers[user.id]?
        users.peers[user.id] = {peerPort: flags.peerPort}
        delete xUser.peerPort
    if flags.foto?
      users[user.id].foto = flags.foto
      delete xUser.foto
    if flags.note?
      users[user.id].note = flags.note
      delete xUser.note
    unmodifiedAttrKeys = Object.keys xUser
    if unmodifiedAttrKeys?
      for attrKey in unmodifiedAttrKeys
        users[user.id][attrKey] = xUser[attrKey]
    localStorage.setItem storeKey, JSON.stringify(users)
    user
  
  getPeers: () ->
    storeKey = 'comm.users'
    users = JSON.parse(localStorage.getItem(storeKey))
    if users.peers?
      peers = []
      for peerId in Object.keys(users.peers)
        peer = users[peerId]
        peer.id = parseInt peerId
        peer.peerPort = users.peers[peerId].peerPort
        peers.push peer
      return peers
    null

  getChat: (peer = null) ->
    if peer?
      # no error-handling if peer not in localStroage
      storeKey = 'comm.users'
      users = JSON.parse(localStorage.getItem(storeKey))
      return users[peer.id].chat
    else
      conferenceKey = 'comm.conference'
      conference = JSON.parse(localStorage.getItem(conferenceKey))
      return conference

  addChatMessage: (messageText, peer, p2p = false) ->
    if p2p
      # no error-handling if peer not in localStroage
      storeKey = 'comm.users'
      users = JSON.parse(localStorage.getItem(storeKey))
      chat = users[peer.id].chat
      unless chat?
        chat = {}
        users[peer.id]['chat'] = chat
      chat[new Date().getTime()] = messageText
      msgKeys = Object.keys(chat)
      if msgKeys.lenght >= this._maxNumChatP2PChatMsgs
        delete chat[msgKeys.sort()[0]]
      localStorage.setItem storeKey, JSON.stringify(users)
      return chat
    else
      conferenceKey = 'comm.conference'
      conference = JSON.parse(localStorage.getItem(conferenceKey))
      unless conference?
        conference = {}
      entry = {}
      entry[peer.id] = messageText
      conference[new Date().getTime()] = entry
      msgKeys = Object.keys(conference)
      if msgKeys.lenght >= this._maxNumChatBCChatMsgs
        delete conference[msgKeys.sort()[0]]
      localStorage.setItem conferenceKey, JSON.stringify(conference)
      return conference

  pathKey: (path) ->
    path[0].timestamp

  getPaths: (user) ->
    storeKey = 'comm.users'
    users = JSON.parse(localStorage.getItem(storeKey))
    if users? then (if users[user.id]? then users[user.id].paths else null) else null

  getPath: (user, pathKey = null, notDone = true) ->
    paths = this.getPaths user
    if paths?
      unless pathKey?
        pathKeys = Object.keys(paths)
        pathKey = pathKeys[pathKeys.length-1]
      curPath = paths[pathKey]
      if (!curPath) || (notDone && curPath.done) then null else curPath.entries
    else
      null

  # no error-handling if user not in localStroage
  # TODO - currently just next path is added without checking last path for done.
  #        no way yet to continue path before last path
  startTracePath: (user, position, db = {}) ->
    storeKey = 'comm.users'
    users = JSON.parse(localStorage.getItem(storeKey))
    paths = users[user.id].paths
    unless paths?
      paths = {}
      users[user.id]['paths'] = paths
    now = new Date().getTime()
    path = {done: false, entries: [{timestamp: now, lat: position.lat, lng: position.lng}]}
    paths[now] = path
    localStorage.setItem storeKey, JSON.stringify(users)
    db['users'] = users
    path.entries

  # creates path if none exists for user or selected path is done
  # no error-handling if pathKey doesn't exist
  addToPath: (user, position, path = null) ->
    storeKey = 'comm.users'
    users = JSON.parse(localStorage.getItem(storeKey))
    paths = users[user.id].paths
    if paths?
      if path?
        pathKey = path[0].timestamp
      else
        pathKeys = Object.keys(paths)
        pathKey = pathKeys[pathKeys.length-1]
      curPath = paths[pathKey]
    else
      db = {}
      curPath = startTracePath user, position, db
      users = db.users
    curPath.entries.push {timestamp: new Date().getTime(), lat: position.lat, lng: position.lng}
    localStorage.setItem storeKey, JSON.stringify(users)
    curPath.entries

  deleteFromPath: (user, pathKey, index) ->
    storeKey = 'comm.users'
    users = JSON.parse(localStorage.getItem(storeKey))
    paths = users[user.id].paths
    paths[pathKey].entries.splice index, 1
    localStorage.setItem storeKey, JSON.stringify(users)
    paths[pathKey].entries

  # no error-handling if user not in localStroage
  # no error-handling if paths doesn't exist
  stopTracePath: (user, curPath = null) ->
    storeKey = 'comm.users'
    users = JSON.parse(localStorage.getItem(storeKey))
    paths = users[user.id].paths
    if curPath?
      path = paths[curPath[0].timestamp]
    else
      pathKeys = Object.keys(paths)
      path = paths[pathKeys[pathKeys.length-1]]
    if path.entries.length >= 2
      path.done = true
    else
      delete paths[path.entries[0].timestamp]
    localStorage.setItem storeKey, JSON.stringify(users)
    path.entries

  # no error-handling if user not in localStroage
  # no error-handling if paths doesn't exist
  deleteTracePath: (user, pathKey = null) ->
    storeKey = 'comm.users'
    users = JSON.parse(localStorage.getItem(storeKey))
    paths = users[user.id].paths
    unless pathKey?
      pathKeys = Object.keys(paths)
      pathKey = pathKeys[pathKeys.length-1]
    delete paths[pathKey]
    localStorage.setItem storeKey, JSON.stringify(users)

  storePoi: (poi, flatten = true) ->
    poiKey = StorageController.poiKey poi
    if flatten
      StorageController._storeWithSeparateLocation poiKey, poi
    else
      localStorage.setItem poiKey, JSON.stringify(poi)

  @_storeWithSeparateLocation: (poiKey, poi) ->
    StorageController.instance().saveLocation {id: poi.locationId,\
                                               lat: poi.lat,\
                                               lng: poi.lng,\
                                               address: poi.address}, {poi: {id: poi.id}}
    locationAttrs = ['lat','lng','address']
    storePoi = {}
    for key in Object.keys(poi)
      if locationAttrs.indexOf(key) == -1
        storePoi[key] = poi[key]
    localStorage.setItem poiKey, JSON.stringify(storePoi)
  
  storePoiNote: (poi, note) ->
    poiKey = StorageController.poiKey(poi)
    StorageController._storeWithoutPoi poiKey, note

  # if there is a poi in the note (backend-push or view-object) then save without.
  # TODO - prepare store-json when receiving the response - and then add view-attributes
  #        or even better - use function-params for persistable entities
  @_storeWithoutPoi: (poiKey, note) ->
    if note.poi?
      notePoi = note.poi
      delete note.poi
      poiNoteClone = JSON.parse(JSON.stringify(note))
      storedJSON = Storage.Model._storeWithSeparateUser poiKey, poiNoteClone
      note.poi = notePoi
      storedJSON
    else
      StorageController._storeWithSeparateUser poiKey, note

  @_storeWithSeparateUser: (poiKey, note) ->
    if note.user
      StorageController.instance().saveUser note.user
      user = note.user
      delete note.user
      note.userId = user.id
      storedPoi = StorageController.instance().addToList poiKey, 'notes', note, false, Storage.Model.noteSort()
      delete note.userId # FIXME - maybe it existed before?
      note.user = user
    else
      storedPoi = StorageController.instance().addToList poiKey, 'notes', note, false, Storage.Model.noteSort()
    storedPoi

  # directory path for storing with file-api
  @poiNoteAttachmentPath: (poiNote) ->
    ['poiNotes', 'attachments', ''+poiNote.id]

  @isFileBased: () ->
    #StorageController._FS?
    Comm.FileUtils._FS?
    #false

  getPoiForLocation: (locationId) ->
    storeKey = 'comm.locations'
    locations = JSON.parse localStorage.getItem(storeKey)
    if locations? && locations.pois?
      poi = locations.pois[locationId]
#      if poi?
#        poiKey = StorageController.poiKey {id: poi.id}
#        #JSON.parse(localStorage.getItem(poiKey))
#        this.get poiKey
    else
      null

  getPoi: (poiId) ->
    poiKey = StorageController.poiKey {id: poiId}
    JSON.parse(localStorage.getItem(poiKey))

  getPois: (callback = null) ->
    locations = this.get 'comm.locations'
    pois = []
    for key, i in Object.keys(localStorage)
      #console.log(key)
      #document.writeln i+'. key = '+key+'<br>'
      if key.match(/^comm\.poi\./)?
        poi = this.get key
        location = locations[poi.locationId]
        poi.lat = location.lat
        poi.lng = location.lng
        poi.address = location.address
        if callback == null or callback(poi)
          pois.push poi
    pois

  clearCache: (flags = {tiles: null, poiNotes: null, users: null}) ->
    #this.delete('tiles')
    if StorageController.isFileBased()
      # for dirName in VoyageX.MapControl.instance()._offlineZooms
      #   this._removeDirectory dirName
      # this._removeDirectory 'poiNotes'
      # this._removeDirectory 'users'
      Comm.FileUtils.instance().clearCache(flags)
    for key, i in Object.keys(localStorage)
      if (key.match(/\.poi\./)? || key.match(/\.locations$/)?) && (!(flags.poiNotes?&&flags.poiNotes))
        continue
      if key.match(/\.users$/)? && (!(flags.users?&&flags.users))
        continue
      console.log('StorageController - clearCache: deleting \''+key+'\' ...')
      this.delete(key)

  loadAndPrefetchTile: (prefetchParams) ->
    # sC = this
    # this._checkedTileLoadQueue prefetchParams.xYZ, prefetchParams.promise, true, true, (queueEntry) ->
    #     console.log('StorageController - loadAndPrefetchTile: '+StorageController.tileKey(prefetchParams.xYZ))
    #     sC._getTileFile prefetchParams.xYZ, 1, prefetchParams
    #     #prefetchParams.promise = prefetchParams.deferred.promise()
    #     #queueEntry.promise = prefetchParams.promise
    Comm.FileUtils.instance().loadAndPrefetchTile prefetchParams

  prefetchTile: (prefetchParams) ->
    # sC = this
    # this._checkedTileLoadQueue prefetchParams.xYZ, prefetchParams.promise, true, false, (queueEntry) ->
    #     console.log('StorageController - prefetchTile: '+StorageController.tileKey(prefetchParams.xYZ))
    #     sC._getTileFile prefetchParams.xYZ, 2, prefetchParams
    #     #prefetchParams.promise = prefetchParams.deferred.promise()
    #     #queueEntry.promise = prefetchParams.promise
    #     #queueEntry.storeFile = false
    Comm.FileUtils.instance().prefetchTile prefetchParams
  
  resolveOnlineNotInOfflineZooms: (tileUrl, deferredModeParams) ->
    # #deferredModeParams.tileUrl = readyImage
    # deferredModeParams.deferred.resolve tileUrl
    # view = deferredModeParams.view
    # if view?
    #   delete this._tileLoadQueue[StorageController.tileKey([view.tile.column, view.tile.row, view.zoom])]
    Comm.FileUtils.instance().resolveOnlineNotInOfflineZooms tileUrl, deferredModeParams

  resolveOfflineNotInCache: (readyImage, deferredModeParams) ->
    # deferredModeParams.tileUrl = readyImage
    # deferredModeParams.deferred.resolve readyImage
    # view = deferredModeParams.view
    # if view?
    #   delete this._tileLoadQueue[StorageController.tileKey([view.tile.column, view.tile.row, view.zoom])]
    Comm.FileUtils.instance().resolveOfflineNotInCache readyImage, deferredModeParams

  storeTile: (xYZ, data, promise = null, deferredModeParams = null) ->
    # if promise != null
    #   # @see getTile
    #   unless @_tileLoadQueue[StorageController.tileKey(xYZ)]?
    #     @_tileLoadQueue[StorageController.tileKey(xYZ)] = { promise: promise, deferred: false, storeFile: true }
    #   else
    #     console.log('storeTile - promise for '+StorageController.tileKey(xYZ)+' already stored in queue ...')
    #   return promise

    if StorageController.isFileBased()
      #this._storeTileAsFile xYZ, null, data, deferredModeParams
      Comm.FileUtils.instance().storeTile xYZ, data, promise, deferredModeParams
    else
      tileMeta = localStorage.getItem 'comm.tiles.tileMeta'
      if tileMeta == null
        @_tileMeta = { tilesByteSize: 0, numTiles: 0 }
      else
        @_tileMeta = JSON.parse(tileMeta)

      storeKey = 'comm.tiles.'+data.properties.id
      stored = localStorage.getItem storeKey
      if stored == null
#        tileStoreZ = {}
#        yEntry = {}
#        yEntry[xYZ[1]] = data
#        tileStoreZ[xYZ[0]] = [yEntry]
#        localStorage.setItem 'comm.tiles.'+xYZ[2], JSON.stringify(listEntries)
#TODO:refactored when started FileUtils        delete @_tileLoadQueue[StorageController.tileKey(xYZ)]
        localStorage.setItem storeKey, data.properties.data
        @_tileDB[storeKey] = data.properties.data
        @_tileMeta.numTiles = @_tileMeta.numTiles+1
        @_tileMeta.tilesByteSize = @_tileMeta.tilesByteSize+data.properties.data.length

      localStorage.setItem 'comm.tiles.tileMeta', JSON.stringify(@_tileMeta)
  
  getTile: (xYZ, deferredModeParams = null) ->
    if StorageController.isFileBased()
      # sC = this
      # #if deferredModeParams.promise == null
      # #  deferredModeParams.promise = deferredModeParams.deferred.promise()
      # this._checkedTileLoadQueue xYZ, deferredModeParams.promise, false, true, (queueEntry) ->
      #     console.log('StorageController - getTile: '+StorageController.tileKey(xYZ))
      #     sC._getTileFile xYZ, 0, deferredModeParams
      #     #queueEntry.promise = deferredModeParams.promise
      # deferredModeParams.promise
      Comm.FileUtils.instance().getTile xYZ, deferredModeParams
    else
      storeKey = StorageController.tileKey(xYZ)
#TODO:refactored when started FileUtils              stored = @_tileLoadQueue[storeKey]
#TODO:refactored when started FileUtils              if stored?
#TODO:refactored when started FileUtils                #console.log('getTile - stored in queue: '+storeKey); 
#TODO:refactored when started FileUtils                return stored.promise
      stored = @_tileDB['comm.tiles.'+storeKey]
      unless stored?
#        stored = @_tileLoadQueue[storeKey]
#        unless stored?
          stored = localStorage.getItem 'comm.tiles.'+storeKey
          @_tileDB['comm.tiles.'+storeKey] = stored
#        else
#          console.log('stored in queue: '+storeKey); 
      # for backward-compatibility
      if stored?
        stored
      else
        null

  storePoiNoteAttachment: (poiNote, data, deferredModeParams = null) ->
    if StorageController.isFileBased()
      #this._storePoiNoteAttachmentAsFile poiNote, null, data, deferredModeParams
      Comm.FileUtils.instance()._storeAsFile ['poiNotes', 'attachments', poiNote.id], null, data, deferredModeParams
    else
      attachmentMeta = localStorage.getItem 'comm.poiNotes.attachmentMeta'
      if attachmentMeta == null
        @_attachmentMeta = { bytes: 0, count: 0 }
      else
        @_attachmentMeta = JSON.parse(attachmentMeta)

      storeKey = StorageController.poiNoteAttachmentKey poiNote
      stored = localStorage.getItem storeKey
      if stored == null
        localStorage.setItem storeKey, data
        @_attachmentMeta.count = @_attachmentMeta.count+1
        @_attachmentMeta.bytes = @_attachmentMeta.bytes+data.length

      localStorage.setItem 'comm.poiNotes.attachmentMeta', JSON.stringify(@_attachmentMeta)

  storeUserPhoto: (user, data, deferredModeParams = null) ->
    if StorageController.isFileBased()
      Comm.FileUtils.instance()._storeAsFile ['users', 'photos', user.id], null, data, deferredModeParams
    else
      fotoMeta = localStorage.getItem 'comm.users.fotoMeta'
      if fotoMeta == null
        @_fotoMeta = { bytes: 0, count: 0 }
      else
        @_fotoMeta = JSON.parse(fotoMeta)

      storeKey = StorageController.poiNoteAttachmentKey poiNote
      stored = localStorage.getItem storeKey
      if stored == null
        localStorage.setItem storeKey, data
        @_fotoMeta.count = @_fotoMeta.count+1
        @_fotoMeta.bytes = @_fotoMeta.bytes+data.length

      localStorage.setItem 'comm.users.fotoMeta', JSON.stringify(@_fotoMeta)

  getPoiNoteAttachment: (poiNote, deferredModeParams = null) ->
    storeKey = StorageController.poiNoteAttachmentKey poiNote
    if StorageController.isFileBased()
      console.log('getPoiNoteAttachment - '+storeKey)
      Comm.FileUtils.instance().getPoiNoteAttachmentFile poiNote, deferredModeParams
      deferredModeParams.promise
    else
      stored = localStorage.getItem storeKey
      if stored?
        stored
      else
        null

  getUserPhoto: (user, deferredModeParams = null) ->
    storeKey = StorageController.userPhotoKey user
    if StorageController.isFileBased()
      console.log('getUserPhoto - '+storeKey)
      Comm.FileUtils.instance().getUserPhotoFile user, deferredModeParams
      deferredModeParams.promise
    else
      stored = localStorage.getItem storeKey
      if stored?
        stored
      else
        null

  storeImage: (xYZ, tileDataUrl, deferredModeParams = null) ->
    storeKey = StorageController.tileKey(xYZ)
    geoJSON = {
        properties: {
            id: storeKey,
            data: tileDataUrl,
            created_at: Date.now()
          },
        geometry: {
            coordinates: [-1.0, -1.0] # TODO
          }
      }
    console.log 'caching tile: '+storeKey
    this.storeTile xYZ, geoJSON, null, deferredModeParams

  hasQueue: () ->
    uploadQKey = 'comm.uploadQ.poiNotes'
    localStorage.getItem(uploadQKey)?

  @storeUpload: (poi, poiNote, callback, attachmentData, deferredModeParams = null) ->
    APP.storage().storeUpload poi, poiNote, callback, attachmentData, deferredModeParams

  storeUpload: (poi, poiNote, callback, attachmentData, deferredModeParams = null) ->
    @_uploadQ.queueUpload poi, poiNote, callback, attachmentData, deferredModeParams

  # called with params only for instant upload when app is online
  uploadQueue: (qPoi = null, qNewNote = null) ->
    uploadQKey = 'comm.uploadQ.poiNotes'
    stored = localStorage.getItem(uploadQKey)
    qEntries = JSON.parse(stored)
    if qPoi?
      qEntries = [{note: qNewNote, poi: qPoi, fileName: qEntries[0].fileName}]
    if qEntries?
      perPoiList = { numLeft: qEntries.length }
      for qEntry in qEntries
        # TODO - cache poi and location and don't load from localstorage for each q-entry (poiNote) 
        #        better: store them right-away within poi context. (time is saved anyway) 
        if qEntry.note?
          poi = qEntry.poi
          poiNote = qEntry.note
        else
          poiKey = StorageController.poiKey {id: qEntry.poiId}
          poi = StorageController.instance().get poiKey
          for n in poi.notes
            if n.id == qEntry.id
              poiNote = n
              break
        location = StorageController.instance().getLocation poi.locationId

        # deferredModeParams = { deferred: $.Deferred(),\
        #                        promise: null }
        # deferredModeParams.promise = deferredModeParams.deferred.promise()
        deferred = $.Deferred()
        deferredModeParams = { deferred: deferred,\
                               promise: deferred.promise() }
        ((location, poi, poiNote, fileName, perPoiList) ->
             deferredModeParams.promise.then (url = null, file = null) ->
                 perPoiList.numLeft = perPoiList.numLeft - 1
                 unless perPoiList[poi.id]?
                   perPoiList[poi.id] = { poi: poi,\
                                          location: location,\
                                          fileData: {} }
                 if file?
                   perPoiList[poi.id].fileData[poiNote.id] = { file: file, name: fileName }
                 if perPoiList.numLeft == 0
                   delete perPoiList.numLeft
                   for entryKey in Object.keys(perPoiList)
                     # cb is only needed for sync with response - but now we use faye-callback
                     # origCallback = window.afterUploadPhoto = (poi, newNotes) defined in upload_helper
                     # .cb is called from UploadHelper-batchupload when APP.model().syncUploadCachedQPoiData
                     #cb = { cb: (origCallback) ->
                     #           Comm.UploadQ.instance().syncResponseCallback location, poi, origCallback }
                     batchUpload perPoiList[entryKey]#, cb
        )(location, poi, poiNote, qEntry.fileName, perPoiList) 
        if poiNote.attachment? && (!poiNote.attachment.content_type.match(/^embed:/)?)
          #this._getPoiNoteAttachmentFile poiNote, deferredModeParams
          Comm.FileUtils.instance().getPoiNoteAttachmentFile poiNote, deferredModeParams
        else
          deferredModeParams.deferred.resolve()
    true

  # reserved listKeys:
  # push: creates/uses an array for entries stored with storeKey
  # if an array is defined for a storeKey then there can't be any other objects defined aside (@see this.pop())
  addToList: (storeKey, listKey, data, fifo = true, insertPosCB = null) ->
    stored = localStorage.getItem(storeKey)
    if stored == null
      if listKey == 'push'
        listEntries = if data instanceof Array then data else [data]
      else
        listEntries = {}
        @_jsonObjects[storeKey] = listEntries
        listEntries[listKey] = if data instanceof Array then data else [data]
      localStorage.setItem(storeKey, JSON.stringify(listEntries))
      listEntries
    else
      # listKey == null: ^[
      # listKey != null: ^.+?__listKey__:\s*[
      listDetection = new RegExp('^(|.*?"'+listKey+'":\\s*)\\[')
      if stored.trim().match(listDetection) == null
        alert('expected Object/List - change of EntryType not implemented')
      else
        storedJSON = @_jsonObjects[storeKey]
        unless storedJSON?
          storedJSON = JSON.parse(stored)
          @_jsonObjects[storeKey] = storedJSON
        if listKey == 'push'
          if data instanceof Array
            for entry, i in data
              if fifo
                storedJSON.splice 0, 0, data[data.length-1-i]
              else
                storedJSON.push data
          else
            if fifo
              storedJSON.splice 0, 0, data
            else
              storedJSON.push data
        else
          if insertPosCB?
            inserted = false
            for d, idx in storedJSON[listKey]
              if insertPosCB d, data
                storedJSON[listKey].splice idx, 0, data
                inserted = true
                break
            unless inserted
              storedJSON[listKey].push data
          else if fifo
            storedJSON[listKey].splice 0, 0, data
          else
            storedJSON[listKey].push data
        localStorage.setItem(storeKey, JSON.stringify(storedJSON));
      storedJSON

  get: (storeKey, listKey = null) ->
    # FIXME @_jsonObjects is an internal cache-object and should not be exposed to concurrent access
    #       readonly but 'live' copy -> wrapper object! with methods getItem() for [] and real object 
    @_jsonObjects[storeKey] || JSON.parse(localStorage.getItem(storeKey))

  getNumElements: (storeKey, listKey = null) ->
#    # TODO listKey != null, id might not be available
#    if @_jsonObjects[storeKey]?
#      Object.keys(@_jsonObjects[storeKey]).length
#    else
#      stored = localStorage.getItem(storeKey)
#      if stored != null then (stored.match(/("id":)/g)||[]).length else 0
#    #stored = localStorage.getItem(storeKey)
#    #(if stored != null then Math.round(localStorage[storeKey].length/1024) else 0)+' kB'
    tileMeta = localStorage.getItem 'comm.tiles.tileMeta'
    if tileMeta == null
      0
    else
      @_tileMeta = JSON.parse(tileMeta).numTiles

  getByteSize: (storeKey, listKey = null) ->
    # TODO listKey != null
#    stored = localStorage.getItem(storeKey)
#    if stored != null then stored.length else 0
    tileMeta = localStorage.getItem 'comm.tiles.tileMeta'
    if tileMeta == null
      0
    else
      @_tileMeta = JSON.parse(tileMeta).tilesByteSize

  delete: (storeKey, listKey = null) ->
    # TODO listKey != null
#    window.localStorage.clear()
#    @_tileDB = null
#    @_tileDB = {}
#    @_tileMeta = { tilesByteSize: 0, numTiles: 0 }
#    localStorage.removeItem 'comm.tiles.tileMeta'
    localStorage.removeItem(storeKey)
    if @_jsonObjects[storeKey]?
      @_jsonObjects[storeKey] = null

  # expects an array stored with 'push' as listKey in storeKey-entry
  # TODO cache list-object as well like @_jsonObjects
  pop: (storeKey) ->
    stored = localStorage.getItem(storeKey)
    unless stored == null
      listEntries = JSON.parse(stored)
      if listEntries?
        listEntry = listEntries.pop()
        if listEntries.length >= 1
          localStorage.setItem(storeKey, JSON.stringify(listEntries));
        else
          localStorage.removeItem(storeKey)
        listEntry
    else
      null

  @instance: () ->
    @_SINGLETON

#
# provides readonly-'live'-access to storage-entry
#
class Comm.StorageEntryWrapper
  
  constructor: (jsonObject) ->
    @_jsonObject = jsonObject

  getItem: (key) ->
    @_jsonObject[key]

#
#
#
class Comm.UploadQ
  
  @_SINGLETON = null
  
  constructor: () ->
    UploadQ._SINGLETON = this
    @_poi = null
    @_poiNote = null
    #@_callback = null
    @_file = null
    @_fileName = null
    @_embed = null

#  fileName: () ->
#    @_fileName

  setFile: (file) ->
    @_file = file
    @_embed = null

  setEmbed: (embed) ->
    @_embed = embed
    @_file = null

  # here the storing of the uploads will be completed.
  # after everything is stored: callback will be called
  queueUpload: (poi, poiNote, callback, attachmentData, deferredModeParams = null) ->
    @_poi = poi
    @_poiNote = poiNote
    #@_callback = callback
    @_fileName = null
    if attachmentData.fileName?
      @_fileName = attachmentData.fileName
    if attachmentData.blob?
      unless @_fileName?
        @_fileName = attachmentData.blob.name
      poiNote.attachment = { content_type: attachmentData.blob.type, url: null }
      this.setFile attachmentData.blob
    else if attachmentData.embed?
      this.setEmbed {content: attachmentData.embed, content_type: "embed:#{APP.model().getEmbedType(attachmentData.embed)}"}
    else
      this.setFile null

    uploadQKey = 'comm.uploadQ.poiNotes'
    qEntry = Comm.StorageController.instance().addToList uploadQKey, 'push', { id: poiNote.id, poiId: poi.id, fileName: @_fileName }
    #this.addQEntry poi, poiNote

    unless Comm.StorageController.isFileBased()
      # FIXME - not implemented
      Comm.StorageController.instance().storePoiNoteAttachment @_poiNote, base64ImgDataUrl, deferredModeParams
      cacheStats()
    else
      if @_file?
        deferred = $.Deferred()
        deferredModeParams = { fileUrl: Storage.Model.attachmentUrl,\
                               fileMeta: poiNote.attachment,\
                               fileOwner: poiNote,\
                               deferred: deferred,\
                               promise: deferred.promise() }
        # deferredModeParams.deferred = $.Deferred()
        # deferredModeParams.promise = deferredModeParams.deferred.promise()
        deferredModeParams.promise.then (url) ->
            console.log 'UploadQ - storeUpload: attachmentUrl-promise resolved to: '+url
            poi = UploadQ.instance()._poi
            note = UploadQ.instance()._poiNote
            note.attachment.url = url
            poiKey = Comm.StorageController.poiKey(poi)
            storedPoi = Comm.StorageController.instance().addToList poiKey, 'notes', note, false, Storage.Model.noteSort()
            poi.notes = storedPoi.notes
            callback poi, note
        Comm.StorageController.instance().storePoiNoteAttachment @_poiNote, @_file, deferredModeParams
      else
        poi = UploadQ.instance()._poi
        poiKey = Comm.StorageController.poiKey(poi)
        note = UploadQ.instance()._poiNote
        if @_embed?
          note.attachment = @_embed
        storedPoi = Comm.StorageController.instance().addToList poiKey, 'notes', note, false, Storage.Model.noteSort()
        poi.notes = storedPoi.notes
        callback poi, note

  # this method provides the method to handle the backend-response to a syncUpload
 #syncResponseCallback: (location, poi, origCallback) ->
  # syncResponseCallback: (location, poi) ->
  #   # this method is called after batch-upload with the actually persisted poi/note-data
  #   # from the backend. (especially the backend-ids)
  #   (cbPoi, cbNewPoiNotes) ->
  syncResponseCallback: (location, poi, cbPoi, cbNewPoiNotes) ->
        qPoiId = poi.id
        #oldIdMarker = APP.getMarker poi, true

        if location.id < 0
          location = APP.storage().resetLocation location, { id: cbPoi.locationId,\
                                                             lat: cbPoi.lat,\
                                                             lng: cbPoi.lng,\
                                                             address: cbPoi.address }, cbPoi
          location.poiId = cbPoi.id
          currentAddress = cbPoi.address
          APP.markers().replace {id: poi.locationId}, location
        if poi.id < 0
          if poi.locationId >= 0
            location.poiId = cbPoi.id
            APP.markers().replace {id: poi.locationId}, location
          poiKey = Comm.StorageController.poiKey {id: poi.id}
          localStorage.removeItem poiKey
          poi.id = cbPoi.id
          poi.locationId = location.id
        # 1) find first locally-added/unsynched poiNote
        curNewPoiNoteIdx = 0
        for n, idx in poi.notes
          if n.id < 0
            curNewPoiNoteIdx = idx
            break
        # 2) merge new notes into poi - new notes can be from local-user or from remote-user
        #                               local-notes are marked with local_time_secs <-> -id
        for cbN, cbIdx in cbNewPoiNotes
          if cbN.local_time_secs?
            # there are as many notes with id < 0 as cbNewPoiNotes
            # FIXME that's not true - there could be more notes added meanwhile from other users 
            # so use local_time_secs: <-> id in backend-response (cb)
            qN = poi.notes[curNewPoiNoteIdx]
            if qN.attachment? && (!qN.attachment.content_type.match(/^embed:/))
              ((poiNote, cbPoiNote) ->
                APP.storage()._fileUtils._dirReaders.entries.poiNotes.entries.attachments.entry.getFile poiNote.id, {}, (fileEntry) ->
                    fileEntry.moveTo APP.storage()._fileUtils._dirReaders.entries.poiNotes.entries.attachments.entry, cbPoiNote.id
                    # next can only be done after file is moved
                    # the new note is passed on to display - use local file-system-url to work offline later
                    cbPoiNote.attachment.url = poiNote.attachment.url
                    attachment = $('#poi_notes_container > div[data-id='+cbPoiNote.id+'] img')
                    if attachment.length >= 1
                      attachment.attr('src', poiNote.attachment.url)
                  , (e) ->
                      console.log('syncResponseCallback - '+e)
              )(qN, cbN)
              qN.attachment.url = qN.attachment.url.replace(/[^\/]+$/, cbN.id)
            qN.id = cbN.id
          else
            # new note added by other user - inserted @ backend-calculated pos
            # !! has to be updated in view
            cbN.updateView = true
            poi.notes.splice curNewPoiNoteIdx, 0, cbN
            curNewPoiNoteIdx += 1
          curNewPoiNoteIdx += 1
        
        # save the poi with new id and new note-ids
        poiKey = Comm.StorageController.poiKey {id: poi.id}
        localStorage.setItem poiKey, JSON.stringify(poi)

        UploadQ._removeFromQueue qPoiId

       #origCallback cbPoi, cbNewPoiNotes
        # add all old notes
        for i in [0..poi.notes.length-cbNewPoiNotes.length-1] by 1
          cbPoi.notes.splice i, 0, poi.notes[i]

        APP._syncPoiCB cbPoi, cbNewPoiNotes

#  addQEntry: (poi, poiNote) ->
#    uploadQKey = 'comm.uploadQ.poiNotes'
#    #this.addToList uploadQKey, 'push', { id: poiNote.id, poiId: poi.id, fileName: @_fileName }
#    qNoteEntry = { id: poiNote.id, filename: @_fileName }
#    stored = localStorage.getItem(uploadQKey)
#    qEntries = JSON.parse(stored)
#    qEntry = qEntries[poi.locationId]
#    if qEntry?
#      if qEntry[poi.id]
#        qEntry[poi.id] << qNoteEntry
#      else
#        qEntry[poi.id] = [qNoteEntry]
#    else
#      qEntries[poi.locationId] = {}
#      qEntries[poi.locationId][poi.id] = [qNoteEntry]
#    localStorage.setItem(uploadQKey, JSON.stringify(qEntries))
#    qEntries

  @_removeFromQueue: (qPoiId, qEntries = null) ->
    uploadQKey = 'comm.uploadQ.poiNotes'
    unless qEntries?
      qEntries = JSON.parse(localStorage.getItem(uploadQKey))
    maxIdx = qEntries.length-1
    for idxSub in [0..maxIdx]
      i = maxIdx-idxSub
      qEntry = qEntries[i]
      if qEntry.poiId == qPoiId
        console.log('removeFromQueue - removing Q-entry id: '+qEntry.id)
        qEntries.splice i, 1
        if qEntries.length >= 1
          localStorage.setItem(uploadQKey, JSON.stringify(qEntries));
        else
          localStorage.removeItem(uploadQKey)
    qEntries

  @instance: () ->
    @_SINGLETON
