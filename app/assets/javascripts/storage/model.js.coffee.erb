<% environment.context_class.instance_eval { include Rails.application.routes.url_helpers } %>

class window.Storage.Model
 
  @_SINGLETON = null

  constructor: () ->
    Model._SINGLETON = this

  setHomeBase: (lat, lng, callback) ->
    $.ajax
      type: 'POST'
      dataType: 'json'
      url: '<%= set_user_detail_path(detail: 'home_base') %>'
      data: {lat: lat, lng: lng}
    .done (user) ->
        Comm.StorageController.instance().saveLocation user.home_base, {homeBase: true}
        callback user
    .fail (jqXHR, textStatus) ->
        console.log('TODO: errorhandling')

  addBookmark: (latLng, callback) ->
    $.ajax
      type: 'POST'
      dataType: 'json'
      url: '<%= set_user_detail_path(detail: 'locations') %>'
      data: {lat: latLng[0], lng: latLng[1]}
    .done (user) ->
        Comm.StorageController.instance().saveLocation user.last_location
        bookmark = Comm.StorageController.instance().bookmark user.last_location.id
        callback bookmark
    .fail (jqXHR, textStatus) ->
        console.log('TODO: errorhandling')

  addNote: (locationId, text) ->
    if text.trim() == ''
      return false
    $.ajax
      type: 'POST'
      dataType: 'json'
      url: '<%= set_user_detail_path(detail: 'notes') %>'
      data: {location_id: locationId, text: text}
    .done (user) ->
        Comm.StorageController.instance().saveNote locationId, text
    .fail (jqXHR, textStatus) ->
        console.log('TODO: errorhandling')

  withLocation: (locationId, callback) ->
    location = Comm.StorageController.instance().getLocation locationId
    if location?
      callback location
    else
      $.ajax
        type: 'GET'
        dataType: 'json'
        url: '<%= location_data_path(location_id: ':locationId') %>'.replace(/:locationId/, locationId)
      .done (location) ->
          unless location.id
            location.id = locationId
          Comm.StorageController.instance().saveLocation location
          callback location
      .fail (jqXHR, textStatus) ->
          console.log('TODO: errorhandling')

  loadPois: (lat, lng, callback) ->
    $.ajax
      type: 'GET'
      dataType: 'json'
      url: '<%= pois_path(lat: ':lat', lng: ':lng') %>'.replace(/:lat/, lat).replace(/:lng/, lng)
    .done (msg) ->
        for poi, i in msg.pois
          Model._syncPois poi, callback, i
    .fail (jqXHR, textStatus) ->
        # get from localStorage
        console.log('TODO: maybe get from local storage')
        #existingPoiNotes = Comm.StorageController.get Comm.StorageController.poiKey({id: poiId})

  savePoiNote: (formId, callback) ->
    $("#"+formId).submit()

# {"poi":{"id":2,"lat":51.3767,"lng":7.49389,"address":"Germany, North-Rhine-Westphalia, L704",
# "notes":[
# {"id":97,"user":{"id":101,"username":"tomas"},"text":"frohes fest","attachment":{"content_type":"image/jpeg","id":265,"url":"/assets/files/84/original/hagen_feu-campus.jpg?1419236682","width":500,"height":334}},
# {"id":98,"user":{"id":101,"username":"tomas"},"text":"leider verfahren","attachment":{"content_type":"image/jpeg","id":266,"url":"/assets/files/85/original/berlin_aktion-belaestigung.jpg?1419236733","width":860,"height":649}}
# ]}}
  #
  # store poi
  # if online - compare pois (merge), else use stored poi
  # megr on server? or here? how to diff?
  # each entry is line - line here != line remote
  # if id == id - modified
  # else inserted / removed
  #
  savePoiNote64: (data, callback, poiId = null) ->
    # TODO save before sending - if offline send later
    if poiId != null
      url = '<%= upload_base64_path(id: ':id') %>'.replace(/:id/, poiId)
      data._method = 'put'
    else
      url = '<%= uploads_base64_path %>'
    $.ajax
      type: 'POST'
      dataType: 'json'
      url: url
      data: data
    .done (poiNote) ->
        # TODO: unify json-format, until then avoid circular structure
        Model.setupPoiForNote poiNote.poi
        msg = { poi: poiNote.poi }
        Model.instance().syncWithStorage msg, callback, poiNote
    .fail (jqXHR, textStatus) ->
        #$("#upload_error").html("<ul><-%= escape_javascript(@upload.errors.full_messages.map { |msg| content_tag(:li, msg) }.join.html_safe) %></ul>")
        # get from localStorage
        console.log('TODO: maybe get from local storage')
        #existingPoiNotes = Comm.StorageController.get Comm.StorageController.poiKey({id: poiId})

  saveEmbed: (data, callback, poiId = null) ->
    # TODO save before sending - if offline send later
    if poiId != null
      url = '<%= upload_embed_path(id: ':id') %>'.replace(/:id/, poiId)
      data._method = 'put'
    else
      url = '<%= uploads_embed_path %>'
    $.ajax
      type: 'POST'
      dataType: 'json'
      url: url
      data: data
    .done (poiNote) ->
        # TODO: unify json-format, until then avoid circular structure
        Model.setupPoiForNote poiNote.poi
        msg = { poi: poiNote.poi }
        Model.instance().syncWithStorage msg, callback, poiNote
    .fail (jqXHR, textStatus) ->
        #$("#upload_error").html("<ul><-%= escape_javascript(@upload.errors.full_messages.map { |msg| content_tag(:li, msg) }.join.html_safe) %></ul>")
        # get from localStorage
        console.log('TODO: maybe get from local storage')
        #existingPoiNotes = Comm.StorageController.get Comm.StorageController.poiKey({id: poiId})

  loadPoiNotes: (poiId, poiNoteId, callback) ->
    poi = Comm.StorageController.instance().get Comm.StorageController.poiKey {id: poiId}
    if poi? && poi.notes && poi.notes.length >= 1
      # TODO now only returns stored poiNotes - but we have to check list for update
      if poiNoteId?
        for poiNote in poi.notes
          if poiNote.id == poiNoteId
            callback poi
            return poi.notes
      else
        callback poi
        return poi.notes
    unless poiNoteId?
      poiNoteId = -1
    $.ajax
      type: 'GET'
      dataType: 'json'
      url: '<%= upload_comments_path(poi_id: ':poi_id', poi_note_id: '') %>'.replace(/:poi_id/, poiId)+poiNoteId
    .done (msg) ->
        Model.setupPoiForNote msg.poi
        for note, i in msg.poi.notes
          Model.instance().syncWithStorage msg, callback, note, i+1, msg.poi.notes.length-1-i
    .fail (jqXHR, textStatus) ->
        # get from localStorage
        console.log('TODO: maybe get from local storage')
        #existingPoiNotes = Comm.StorageController.get Comm.StorageController.poiKey({id: poiId})

  # TODO: dataType: 'json' and callback impl
  photoNav: (lat, lng, callback = null) ->
    $.ajax
      type: 'GET'
      dataType: 'script'
      url: '<%= photo_nav_path(lat: ':lat', lng: ':lng') %>'
           .replace(/:lat/, lat)
           .replace(/:lng/, lng)
#    .done (msg) ->
#        for note, i in msg.poi.notes
#          Model.instance().syncWithStorage msg, callback, note, i
#    .fail (jqXHR, textStatus) ->
#        # get from localStorage
#        console.log('TODO: maybe get from local storage')
#        #existingPoiNotes = Comm.StorageController.get Comm.StorageController.poiKey({id: poiId})
    if callback?
      callback { pois: 'TODO' }

  syncWithStorage: (msg, callback, note, numAdded = 1, numLeft = 0) ->
    # store image
    attachmentUrl = Model._viewPoiNoteAttachment note
    # @see leaflet-functionaltilelayer _loadTile: function / MapControl - drawTile
    if (typeof attachmentUrl == 'string') 
      console.log 'Model - syncWithStorage: attachmentUrl-string = '+attachmentUrl
      Model._syncPoiNotes msg.poi, Comm.StorageController.poiKey(msg.poi), note, numAdded, numLeft, callback
    else if (typeof attachmentUrl.then == 'function') 
      # Assume we are dealing with a promise.
      attachmentUrl.then (url) ->
          console.log 'Model - syncWithStorage: attachmentUrl-promise resolved to: '+url
          note.attachment.url = url
          Model._syncPoiNotes msg.poi, Comm.StorageController.poiKey(msg.poi), note, numAdded, numLeft, callback

  @setupPoiForNote: (poi) ->
    storeKey = Comm.StorageController.poiKey {id: poi.id}
    storedPoi = Comm.StorageController.instance().get storeKey
    unless storedPoi
      unless poi.notes?
        poi.notes = []
      Model._storeWithSeparateLocation storeKey, poi

  @_syncPois: (poi, callback, i) ->
    storeKey = Comm.StorageController.poiKey poi
    localPoiData = Comm.StorageController.instance().get storeKey
    if localPoiData?
      # TODO attributes / structure will not change. 
      # currently: take all from remote, only add local which are not part of response-poi
      for key in Object.keys(localPoiData)
        if poi[key]?
          if key == 'notes'
            # TODO compare and clean up attachments; currently notes are not part of the response - they are handled separately
            console.log('TODO: Model - _syncPois: compare and clean up attachments')
        else
          poi[key] = localPoiData[key]
    else
      unless poi.notes?
        poi.notes = []
    Model._storeWithSeparateLocation storeKey, poi
    callback poi

  @_storeWithSeparateLocation: (poiKey, poi) ->
    Comm.StorageController.instance().saveLocation {id: poi.locationId,\
                                                    lat: poi.lat,\
                                                    lng: poi.lng,\
                                                    address: poi.address}, {poi: {id: poi.id}}
    locationAttrs = ['lat','lng','address']
    storePoi = {}
    for key in Object.keys(poi)
      if locationAttrs.indexOf(key) == -1
        storePoi[key] = poi[key]
    localStorage.setItem poiKey, JSON.stringify(storePoi)

  @_syncPoiNotes: (poi, poiKey, note, numAdded, numLeft, callback) ->
    poiKey = Comm.StorageController.poiKey(poi)
    existingPoiData = Comm.StorageController.instance().get poiKey
    if existingPoiData? 
      unless existingPoiData.notes? && Model._findPoiNote(note, existingPoiData.notes) >= 0
        existingPoiData = Model._storeWithoutPoi poiKey, note
        #existingPoiData.notes.push note
      poi.notes = existingPoiData.notes
    unless numLeft >= 1
      if poi.notes? && poi.notes.length >= 1
        newNotes = poi.notes.slice poi.notes.length-numAdded
      else
        newNotes = [note]
      callback poi, newNotes

  @_storeWithoutPoi: (poiKey, note) ->
    if note.poi?
      notePoi = note.poi
      delete note.poi
      poiNoteClone = eval("("+JSON.stringify(note)+")")
      storedJSON = Comm.StorageController.instance().addToList poiKey, 'notes', poiNoteClone, false
      note.poi = notePoi
      storedJSON
    else
      Comm.StorageController.instance().addToList poiKey, 'notes', note, false
  
  @_findPoiNote: (note, notes) ->
    for n, idx in notes
      if n.id == note.id
        return idx
    -1

#  @poiNotes: (newPoiNotes, storedPoiNotes) ->
#    # poinotes must always be sorted by id, also indicating their age-relation
#    merged = []
#    sIdx = 0
#    for nIdx in [0..newPoiNotes.length-1] by 1
#      for i in [sIdx..storedPoiNotes.length-1] by 1
#        sIdx = i+1
#        if newPoiNotes[nIdx].id < storedPoiNotes[i].id
#          merged.push newPoiNotes[nIdx]
#          for j in [nIdx..newPoiNotes.length-1] by 1
#            if newPoiNotes[j].id < storedPoiNotes[i].id
#              merged.push newPoiNotes[nIdx]
#            break
#        else
#          merged.push storedPoiNotes[i]
#      if i >= storedPoiNotes.length
#        break
#    # TODO add remaining poiNotes - only one of the following will continue
#    for i in [nIdx..newPoiNotes.length-1] by 1
#      merged.push newPoiNotes[i]
#    for i in [sIdx..storedPoiNotes.length-1] by 1
#      merged.push storedPoiNotes[i]
#    merged

  @_viewPoiNoteAttachment: (poiNote) ->
    storeKey = Comm.StorageController.poiNoteAttachmentKey poiNote
    if Comm.StorageController.isFileBased()
      # use File-API
      console.log '_viewPoiNoteAttachment - ........................................'+storeKey
      # TODO ? maybe just query offline-zoom-files - see MapControl.tileUrl else of if view.zoom in mC._offlineZooms
      # NO - because other zoom-levels may trigger some extra-action (liek prefetch ...)
      deferredModeParams = { attachmentUrl: Model.attachmentUrl,\
                             poiNote: poiNote,\
                             save: true,\
                             deferred: $.Deferred(),\
                             promise: null }
      deferredModeParams.promise = deferredModeParams.deferred.promise()
      Comm.StorageController.instance().getPoiNoteAttachment poiNote, deferredModeParams
      deferredModeParams.promise
    else
      # use localStorage
      stored = Comm.StorageController.instance().getPoiNoteAttachment poiNote
      unless stored?
        Model.attachmentUrl poiNote
      else
        console.log 'using cached tile: '+storeKey
        stored
   
  @attachmentUrl: (poiNote, deferredModeParams = null) ->
    if APP.isOnline()
      readyImage = Model._SINGLETON.cacheAttachment poiNote, deferredModeParams
    else
      readyImage = Model._SINGLETON._notInCacheImage $('#attachment_canvas')[0], poiNote
      if deferredModeParams != null
        Comm.StorageController.instance().resolveOfflineNotInCache readyImage, deferredModeParams
      readyImage

  cacheAttachment: (poiNote, deferredModeParams = null) ->
    if Comm.StorageController.isFileBased()
      attachment = this._loadReadyImage poiNote, deferredModeParams
    else
      attachment = Comm.StorageController.instance().getPoiNoteAttachment poiNote, deferredModeParams
      unless attachment?
        #console.log 'cacheAttachment - '+Comm.StorageController.poiNoteAttachmentKey(poiNote)
        attachment = this._loadReadyImage poiNote, deferredModeParams
      attachment

  @instance: () ->
    Model._SINGLETON

  # has to be done sequentially becaus we're using one canvas for all
  _loadReadyImage: (poiNote, deferredModeParams = null) ->
    #if window.location.host != poiNote.attachment.url.match(/^https?:\/\/([^\/]+)/)[1]
    urlHostMatch = poiNote.attachment.url.match(/^https?:\/\/([^\/]+)/)
    if urlHostMatch? && window.location.host != urlHostMatch[1]
      console.log '_loadReadyImage - returning crossOrigin-url for poiNote['+poiNote.id+'].attachment: '+poiNote.attachment.url
      if deferredModeParams?
        deferredModeParams.deferred.resolve poiNote.attachment.url
      return poiNote.attachment.url
    if deferredModeParams == null
      promise = true
      deferred = $.Deferred()
    img = new Image
    img.crossOrigin = ''
    #img.crossOrigin = poiNote.attachment.url.match(/^https?:\/\/([^\/]+)/)[1]
    img.onload = (event) ->
      base64ImgDataUrl = Model._SINGLETON._toBase64 $('#attachment_canvas')[0], poiNote, this # event.target
      unless Comm.StorageController.isFileBased()
        Comm.StorageController.instance().storePoiNoteAttachment poiNote, base64ImgDataUrl, deferredModeParams
        cacheStats()
      else
        # actually we could store base64 in file as wall
        #Comm.StorageController.instance().storePoiNoteAttachment poiNote, base64ImgDataUrl, deferredModeParams
        $('#attachment_canvas')[0].toBlob((blob) ->
            Comm.StorageController.instance().storePoiNoteAttachment poiNote, blob, deferredModeParams
          )
      if promise
        deferred.resolve(base64ImgDataUrl)
    if promise
      readyImg = deferred.promise()
      img.src = poiNote.attachment.url
      readyImg
    else
      img.src = poiNote.attachment.url
      null

  _toBase64: (canvas, poiNote, image) ->
    canvas.width = poiNote.attachment.width
    canvas.height = poiNote.attachment.height
    context = canvas.getContext('2d')
    context.drawImage(image, 0, 0)
    canvas.toDataURL(poiNote.attachment.content_type)

  _notInCacheImage: (canvas, poiNote) ->
    canvas.width = poiNote.attachment.width
    canvas.height = poiNote.attachment.height
    context = canvas.getContext('2d')
    context.fillStyle = "black";
    context.fillRect(0,0,poiNote.attachment.width,poiNote.attachment.height);
    context.fillStyle = "white";
    context.fillRect(1,1,poiNote.attachment.width-2,poiNote.attachment.height-2);
    context.fillStyle = "blue";
    context.font = "bold 16px Arial";
    context.fillText("Not Cached", 100, 80);
    context.fillText(poiNote.attachment.content_type, 40, 110);
    canvas.toDataURL(@_tileImageContentType)
