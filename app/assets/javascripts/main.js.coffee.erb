<% environment.context_class.instance_eval { include Rails.application.routes.url_helpers } %>

class window.VoyageX.Main
  
  @_SINGLETON = null
  @_BACKEND = null
  @_STORAGE_CONTROLLER = null
  @_MAP_CONTROL = null
  @_MARKER_MANAGER = null
  @_CHAT_CONTROL = null
  @_COMM_CHANNELS = ['system', 'talk', 'map_events', 'uploads', 'radar']
  @_STORAGE_MODEL = null
  @_UPLOAD_HELPER = null

  constructor: (view, mapOptions, offlineZooms, online) ->
    Main._SINGLETON = this
    window.APP = this
    @_version = new VoyageX.Version [0, 1]
    @_initState = 0
    @_online = online
    @_navigatorOnline = online
    @_view = view
    @_comm = null
    @_realPosition = {lat: -1.0, lng: -1.0}
    @_realPositionWatch = null
    @_moveSensorDistMeters = 25
    @_selectedPosition = {lat: -1.0, lng: -1.0, address: null}
    @_curPOI = null
    #@_initPoisOnMap = []
    Main._STORAGE_MODEL = new Storage.Model()
    Main._UPLOAD_HELPER = new VoyageX.UploadHelper()
    # at first the map need's to be initialized ...
    $(document).ready () ->
        APP._init view, mapOptions, offlineZooms, window.VoyageX.TILE_HANDLER
        # test for address-bar removal / fullscreen @see application.mobile as well
#        if isMobile()
#          if !window.pageYOffset
#            hideAddressBar()

  #
  # TODO - clean initialisation of all components in order to enable modularized usage auf single components
  #        (when reused in another application)
  #
  _init: (view, mapOptions, offlineZooms, tileHandler = null) ->
    APP._initState += 1
    switch APP._initState
      when 1
        Main._BACKEND = new VoyageX.Backend()
        Main._STORAGE_CONTROLLER = new Comm.StorageController((initError) ->
            console.log 'StorageController initialized FileSystem with message: '+(if initError then 'FAILED' else 'OK')
            APP._init view, mapOptions, offlineZooms, tileHandler
          )
      when 2
        # Communication initialisation (Faye-Client)
        APP._comm = new Comm.Comm(APP.userId(),
                                  [['/talk', APP._talkCB, VoyageX.CHANNEL_ENC_KEY],
                                   ['/map_events', view._mapEventsCB, VoyageX.CHANNEL_ENC_KEY],
                                   ['/uploads', APP._uploadsCB, VoyageX.CHANNEL_ENC_KEY],
                                   ['/radar', view._radarCB, VoyageX.CHANNEL_ENC_KEY]],
                                   VoyageX.SYS_CHANNEL_ENC_KEY,
                                   APP._systemCB)
        # Map initialisation (LeafletJS)
        Main._MAP_CONTROL = new VoyageX.MapControl mapOptions, offlineZooms, tileHandler
        Main._MARKER_MANAGER = new VoyageX.MarkerManager APP.map()
        Main._CHAT_CONTROL = new VoyageX.ChatControl()
        # handled in _peers.html.haml
        #Storage.Model.instance().loadPeers (peer) ->
        #  marker = Main.markerManager().add poi.location, Main._markerEventsCB, false
        if APP.signedIn()
          APP.storage().saveUser { id: currentUser.id, username: currentUser.username }, { foto: currentUser.foto }
        APP.initPeers()
        if navigator.geolocation 
          navigator.geolocation.getCurrentPosition(APP._initPositionCB, (error) ->
              #alert('geolocation timed out - manual selection required.\nsetting default location...')
              APP._initPositionCB { coords: { latitude: window.currentUser.lastLocation.lat, longitude: window.currentUser.lastLocation.lng } }
          , { enableHighAccuracy: true, timeout : 5000 })
#       #APP.map().on('locationfound', (e) ->
#       #    alert('found location...')
#       #  )
#       #APP.map().on('locationerror', (e) ->
#       #    alert('geolocation timed out - manual selection required.\nsetting default location...')
#       #  )
        #APP._initPositionCB { coords: { latitude: defaultLatLng[0], longitude: defaultLatLng[1] } }
        if isMobile()
          APP.map().invalidateSize({
              reset: true,
              pan: false,
              animate: false
            })
          $('#panel_control').draggable({
#              start: (event, ui) ->
#                  console.log('dragging ...')
#              ,
#              drag: (event, ui) ->
#                  console.log('dragging ...')
            })
#          $( "#panel_control" ).on( "dragcreate", (event, ui) ->
#                  console.log('dragging ...')
#            )
        $('#zoom_level').html('<span style="color:white;">zoom: '+APP.map().getZoom()+'</span>')
        # next statement removes value from inputs!!
        #$("#network_state").buttonset()
        $('button[value=camera]').focus()
        APP._zoomEnd(null)
        cacheStats()
        $('#user_foto_input_type').buttonset()
        $('#poi_notes_container').scrollpanel({
            prefix: 'pcn-'
          })
        $('#clear_cache').click () ->
          APP.clearCache()

  userId: () ->
    window.currentUser.id

  userName: () ->
    window.currentUser.username

  signedIn: () ->
    window.VoyageX.CHANNEL_ENC_KEY?

  register: (userId) ->
    Main._BACKEND.register userId

  isBackendOnline: () ->
    navigator.onLine && VoyageX.Backend.instance().isOnline()

  isOnline: () ->
    if navigator.onLine
      unless @_navigatorOnline
        @_navigatorOnline = true
        console.log 'Main - isOnline: navigator switched to on-line ...'
        # TODO reload offline-cache files ...  remember them in array? until set data-attr
        #APP.map().invalidateSize({
        #    reset: true,
        #    pan: false,
        #    animate: false
        #  })
      @_online && this.isBackendOnline()
    else
      if @_navigatorOnline
        @_navigatorOnline = false
        console.log 'Main - isOnline: navigator switched to off-line ...'
      false

  setOnline: () ->
    if this.isBackendOnline()
      @_online = true
      Main._MAP_CONTROL._zooms.splice(0, Main._MAP_CONTROL._zooms.length)
      for n in [Main._MAP_CONTROL._minZoom..Main._MAP_CONTROL._maxZoom]
        Main._MAP_CONTROL._zooms.push n
      APP.storage().uploadQueue()
      unless $('#network_state_online').prop('checked')
        $('#network_state_online').prop('checked', true)

  setOffline: () ->
    if @_online
      @_online = false
      Main._MAP_CONTROL._zooms.splice(0, Main._MAP_CONTROL._zooms.length)
      for n in Main._MAP_CONTROL._offlineZooms
        Main._MAP_CONTROL._zooms.push n
      unless $('#network_state_offline').prop('checked')
        $('#network_state_offline').prop('checked', true)

  clearCache: () ->
    Comm.StorageController.instance().clearCache()
    cacheStats()

  resetConnection: (commSettingId) ->
    peerChannelEncKey = $('#i_follow_'+commSettingId).attr('data-channelEncKey')
    for channel in Main.commChannels()
      if channel == 'system'
        continue
      channelPath = '/'+channel
      unless window.VoyageX.USE_GLOBAL_SUBSCRIBE 
        channelPath += VoyageX.PEER_CHANNEL_PREFIX+peerChannelEncKey
      Comm.Comm.unsubscribeFrom channelPath, false
      Comm.Comm.subscribeTo channelPath, Comm.Comm.channelCallBacksJSON[channel].callback

  initPeers: (callback = null) ->
    for peer in initArgs.peers
#window.initArgs.peers.push({id: #{cs.user.id}, username: '#{cs.user.username}', peerPort: {id: #{cs.id}, channel_enc_key: '#{cs.channel_enc_key}'}});
      peerPort = peer.peerPort
      delete peer.peerPort
      lastLocation = peer.lastLocation
      delete peer.lastLocation
      # ---------------------
      poiId = lastLocation.poiId
      if poiId?
        delete lastLocation.poiId
        APP.storage().saveLocation lastLocation, {poi: {id: lastLocation.poiId}}
      else
        if lastLocation.id?
          APP.storage().saveLocation lastLocation
      # ---------------------
      peer.lastLocationId = lastLocation.id
      APP.storage().saveUser peer, {peerPort: peerPort, foto: peer.foto}
      # ---------------------
      if callback?
        callback peer
      #marker = Main.markerManager().add lastLocation, Main._markerEventsCB, {isUserMarker: false, peer: peer}
      marker = APP.getPeerMarker peer, lastLocation
    window.initArgs.peers.splice(0, window.initArgs.peers.length)
    #delete window.initArgs.peers

  # user-marker-tools
  bookmarkLocation: (poiId = -1) ->
    if poiId == -1
      posLatLng = this.getSelectedPositionLatLng()
      #APP.map().panTo(this.getSelectedPositionLatLng())
    else
      poi = APP.storage().get Comm.StorageController.poiKey({id: poiId})
      locationData = APP.storage().getLocation poi.locationId
      posLatLng = [locationData.lat, locationData.lng]
    Storage.Model.instance().addBookmark posLatLng, VoyageX.View.addBookmark

  # user-marker-tools
  radarSettings: () ->
    VoyageX.View.editRadar()

  toggleTrace: (user, pathKey) ->
    path = APP.storage().getPath user, pathKey

    if window.tTDblClick
      isDoubleClick = true
      if path?
        APP.storage().stopTracePath user, path
        APP.view().setTraceCtrlIcon user, marker, 'stop'
      VoyageX.View.editTracePaths user
      return true
    else
      window.tTDblClick = new Date().getTime()
      setTimeout () ->
          delete window.tTDblClick
        , 500

    marker = APP.getOpenPopupMarker true
    if path?
      APP.storage().stopTracePath user, path
      APP.view().setTraceCtrlIcon user, marker, 'stop'
    else
      if user.id == currentUser.id 
        position = {lat: APP._selectedPosition.lat, lng: APP._selectedPosition.lng}
      else
        position = {lat: marker.m.location().lat, lng: marker.m.location().lng}
      APP.storage().startTracePath user, position
      APP.view().setTraceCtrlIcon user, marker, 'start'

  deleteTracePath: (user, pathKey) ->
    APP.view().hideTracePath pathKey
    APP.storage().deleteTracePath user, pathKey
    $('#tp_e_'+pathKey).remove()

  #publishPosition: (bookmarkLocation = false, posLatLng = null, setHomeBase = false) ->
  publishPosition: () ->
    unless posLatLng?
      posLatLng = [@_selectedPosition.lat, @_selectedPosition.lng]
    @_comm.send('/map_events', {type: 'click',\
                                userId: APP.userId(),\
                                lat: posLatLng[0],\
                                lng: posLatLng[1]})#,\
                                #bookmarkLocation: bookmarkLocation,\
                                #setHomeBase: setHomeBase})
    path = APP.storage().getPath currentUser
    if path?
      path = APP.storage().addToPath currentUser, @_selectedPosition, path
      VoyageX.Main.mapControl().drawPath currentUser, path, true
    $('#marker_controls').closest('.leaflet-popup').children('.leaflet-popup-close-button').click()

  initBCChatMessages: () ->
    conference = APP.storage().getChat()
    entries = []
    if conference?
      entryKeys = Object.keys(conference).sort()
      for entryKey, i in entryKeys
        entries.push conference[entryKey]
        userId = parseInt Object.keys(conference[entryKey])[0]
        user = APP.storage().getUser userId
        message = {peer: user, text: conference[entryKey][userId]}
        VoyageX.View.addChatMessage message, user.id == currentUser.id
    entries

  initP2PChatMessages: (peer, messages) ->
    chat = APP.storage().getChat peer
    if chat?
      msgKeys = Object.keys(chat).sort()
      for msgKey, i in msgKeys
        messages.push chat[msgKey]
    messages

  bcChatMessage: (messageText) ->
    APP.storage().addChatMessage messageText, currentUser
    @_comm.send('/talk', {type: 'message',\
                          userId: APP.userId(),\
                          text: messageText})

  p2pChatMessage: (peer, messageText) ->
    APP.storage().addChatMessage messageText, peer, true
    @_comm.send('/talk', {type: 'p2p-message',\
                          userId: APP.userId(),\
                          text: messageText}, peer)

  setHomeBase: () ->
    #this.publishPosition false, null, true
    Storage.Model.instance().setHomeBase @_selectedPosition.lat, @_selectedPosition.lng, (user) ->
        window.currentUser.homebaseLocationId = user.home_base.id

  setSearchRadius: (value) ->
    unless $('#search_radius_display_show').prop('checked')
      $('#search_radius_display_hide').prop('checked', false)
      $('#search_radius_display_show').prop('checked', true)
    VoyageX.SEARCH_RADIUS_METERS = value
    sBs = searchBounds(APP.map().getCenter().lat, APP.map().getCenter().lng, VoyageX.SEARCH_RADIUS_METERS)
    APP.map().fitBounds L.latLngBounds(L.latLng(sBs.lat_south, sBs.lng_west), L.latLng(sBs.lat_north, sBs.lng_east))
    VoyageX.Main.markerManager().searchBounds(VoyageX.SEARCH_RADIUS_METERS, APP.map())
    Storage.Model.instance().setRadarSettings (user) ->
        `;`

  loadLocation: (location, fetch = true) ->
    if location.lat? || !fetch
      APP._initPositionCB { coords: { latitude: location.lat, longitude: location.lng } }, location.address, true
      if isMobile()
        $("#photo_nav_panel").panel("close")
      else
        photoNavPanel.dialog("close")
#      # other 2 tabs will not change content - they are loaded from tsart on
#      selectedTab = $('#photo_nav_panel ul[role=tablist] [class~=ui-tabs-active]').attr('aria-controls')
#      if selectedTab != 'pois_preview'
#        #$('#pois_preview_btn').click()
#        APP.photoNav()
#        $('#'+selectedTab+'_btn').click()
#      else
#        APP.photoNav()
      if location.poiId
        APP.showPOI location.poiId, -1
      else
        $('#current_address').html(location.address+' ('+location.id+')')
        openPopupMarker = APP.getOpenPopupMarker()
        if openPopupMarker? && openPopupMarker != Main.markerManager().get()
          openPopupMarker.closePopup()
        #Main.markerManager().userMarkerMouseOver true
      if APP.map().getZoom() < 15
        APP.map().setZoom 15
      #APP.getUserMarker(true).m.setLocation {lat: location.lat, lng: location.lng}
    else
      Storage.Model.instance().withLocation location.id, (location) ->
          APP.loadLocation location, false

  showPOIs: (location) ->
    Storage.Model.instance().loadPois location.lat, location.lng, (poi) ->
      location = {id: poi.locationId, lat: poi.lat, lng: poi.lng, address: poi.address, poiId: poi.id}
      markerMeta = APP.getMarker poi, true
      if markerMeta?
        markerMeta.m.setLocation location
      else
        Main.markerManager().add location, Main._markerEventsCB
      #APP._initPoisOnMap.push poi

  showPOI: (poiId, poiNoteId) ->
    Storage.Model.instance().loadPoiNotes poiId, poiNoteId, (poi) ->
        #APP.panPosition(poi.lat, poi.lng, poi.address)
        VoyageX.TemplateHelper.openPOINotePopup poi
        APP.view().scrollToPoiNote poiNoteId
    if isMobile()
      $("#photo_nav_panel").panel("close")
    else
      photoNavPanel.dialog("close")

  getSelectedPositionLatLng: () ->
    return [@_selectedPosition.lat, @_selectedPosition.lng]

  _setSelectedPositionLatLng: (marker, lat, lng, address) ->
    poi = {lat: lat, lng: lng}
    if marker == null
      marker = Main.markerManager().add poi, Main._markerEventsCB
    else
      marker = Main.markerManager().sel marker, lat, lng, Main._markerEventsCB
    @_selectedPosition.lat = lat
    @_selectedPosition.lng = lng
    @_selectedPosition.address = address
#    if address != null
#      $('#cur_loc_addr').html(address) 
    if showSearchRadius
      Main.markerManager().searchBounds(VoyageX.SEARCH_RADIUS_METERS, APP.map())

  _zoomEnd: (e) ->
    $('#zoom_level').html('<span style="color:white;">zoom: '+APP.map().getZoom()+'</span>')

  _initPositionCB: (position, address = null, isReInit = false) ->
    #APP._setRealPosition(position) unless isReInit
    location = {lat: position.coords.latitude, lng: position.coords.longitude}
    if isReInit
      marker = Main.markerManager().get()
    else
      marker = Main.markerManager().add location, Main._markerEventsCB, {isUserMarker: true, isPeerMarker: false}
    APP._setSelectedPositionLatLng marker, position.coords.latitude, position.coords.longitude, address
    APP.map().panTo([position.coords.latitude, position.coords.longitude])
    #APP.map().setView [position.coords.latitude, position.coords.longitude], 16
    unless isReInit
      APP.publishPosition()
    APP.showPOIs location

  # check if second-last path is inaccuracyFactor-times than both last and third last
  # wenn die letzten beiden ungefähr gleich groß waren (fehler zurück)
  # und die beiden davor ungefähr gleichgroß waren
  # und der abstand vom letzten punkt zum 3 letzten punkt ungefähr so ist wie der vom 4 letzen zum 3. letzen
  # dann vorlezzten punt entfernen.
  # X-X-X-------X ... don't remove 
  # X-X-------X-X ... remove 
  # X-X-X-------X-------X ... don't remove 
  # ?: also check @_moveSensorDistMeters
  smoothenPath: (user, path) ->
    if path.length >= 5
      inaccuracyFactor1 = 1.25
      inaccuracyFactor2 = 2.0
      maxIdx = path.length - 1
      fourthLastDist = L.latLng(path[maxIdx-4].lat, path[maxIdx-4].lng).distanceTo L.latLng(path[maxIdx-3].lat, path[maxIdx-3].lng)
      thirdLastDist = L.latLng(path[maxIdx-3].lat, path[maxIdx-3].lng).distanceTo L.latLng(path[maxIdx-2].lat, path[maxIdx-2].lng)
      factor1 = fourthLastDist / thirdLastDist
      unless Math.max(factor1, 1/factor1) >= inaccuracyFactor1
        secondLastDist = L.latLng(path[maxIdx-2].lat, path[maxIdx-2].lng).distanceTo L.latLng(path[maxIdx-1].lat, path[maxIdx-1].lng)
        lastDist = L.latLng(path[maxIdx-1].lat, path[maxIdx-1].lng).distanceTo L.latLng(path[maxIdx].lat, path[maxIdx].lng)
        factor2 = secondLastDist / lastDist
        unless Math.max(factor2, 1/factor2) >= inaccuracyFactor1
          factor3 = (lastDist+secondLastDist) / (thirdLastDist+fourthLastDist)
          if factor3 >= inaccuracyFactor2
            shortDist = L.latLng(path[maxIdx-2].lat, path[maxIdx-2].lng).distanceTo L.latLng(path[maxIdx].lat, path[maxIdx].lng)
            factor4 = (thirdLastDist+fourthLastDist) / 2 / shortDist
            unless shortDist >= (thirdLastDist+fourthLastDist)/2*inaccuracyFactor1
              path = APP.storage().deleteFromPath user, APP.storage().pathKey(path), maxIdx-1
              APP.view().hideTracePath APP.storage().pathKey(path)
              VoyageX.Main.mapControl().drawPath currentUser, path
              return true
    false

  isRealPositionWatched: () ->
    APP._realPositionWatch?

  getRealPosition: () ->
     { lat: APP._realPosition.lat, lng: APP._realPosition.lng }

  _setRealPosition: (position) ->
    sBs = window.searchBounds APP._realPosition.lat, APP._realPosition.lng, APP._moveSensorDistMeters
    unless window.withinSearchBounds position.coords.latitude, position.coords.longitude, sBs
      APP._realPosition.lat = trimPosVal(position.coords.latitude)
      APP._realPosition.lng = trimPosVal(position.coords.longitude)
      APP._comm.send('/radar', {type: 'move',\
                                userId: APP.userId(),\
                                lat: APP._realPosition.lat,\
                                lng: APP._realPosition.lng})
      path = APP.storage().getPath currentUser
      if path?
        path = APP.storage().addToPath currentUser, APP._realPosition, path
        unless APP.smoothenPath currentUser, path
          # don't draw gps-location-error
          VoyageX.Main.mapControl().drawPath currentUser, path, true
          # don't set location unless user explicitely want's to by activating path (else might disturb work)
          APP.getUserMarker(true).m.setLocation {lat: APP._realPosition.lat, lng: APP._realPosition.lng}
    APP.watchRealPosition()
  
  stopRealPositionWatch: () ->
    if navigator.geolocation && APP._realPositionWatch?
      navigator.geolocation.clearWatch APP._realPositionWatch
      APP._realPositionWatch = null

  watchRealPosition: () ->
    if navigator.geolocation
      unless APP._realPositionWatch?
        # updates every second
        APP._realPositionWatch = navigator.geolocation.watchPosition APP._setRealPosition, (error) ->
            switch error.code
              when error.PERMISSION_DENIED
                console.log 'ERROR: user did not share geolocation data - disable location-query ...'
                APP._comm.send('/system', {type: 'error', userId: APP.userId(), userName: APP.userName(), userFoto: currentUser.foto, msg: $.format.date(new Date(), 'dd.MM.yyyy HH:mm:ss')+': [watch] - user did not share geolocation data - disable location-query ...'})
                navigator.geolocation.clearWatch APP._realPositionWatch
                APP._realPositionWatch = null
              when error.POSITION_UNAVAILABLE
                console.log 'WARN: could not detect current position - retry ...'
                APP._comm.send('/system', {type: 'error', userId: APP.userId(), userName: APP.userName(), userFoto: currentUser.foto, msg: $.format.date(new Date(), 'dd.MM.yyyy HH:mm:ss')+': [watch] - could not detect current position ...'})
                navigator.geolocation.clearWatch APP._realPositionWatch
                APP._realPositionWatch = null
                setTimeout 'APP._debugWatchRealPosition({coords: {latitude: APP._realPosition.lat, longitude: APP._realPosition.lng}})', VoyageX.Backend._POS_QUERY_INTERVAL_MILLIS
              when error.TIMEOUT
                console.log 'WARN: query position timeout - retry ...'
                APP._comm.send('/system', {type: 'error', userId: APP.userId(), userName: APP.userName(), userFoto: currentUser.foto, msg: $.format.date(new Date(), 'dd.MM.yyyy HH:mm:ss')+': [watch] - query position timeout ...'})
                navigator.geolocation.clearWatch APP._realPositionWatch
                APP._realPositionWatch = null
                setTimeout 'APP._debugWatchRealPosition({coords: {latitude: APP._realPosition.lat, longitude: APP._realPosition.lng}})', VoyageX.Backend._POS_QUERY_INTERVAL_MILLIS
              else
                console.log 'ERROR: unknown error - disable location-query ...'
                APP._comm.send('/system', {type: 'error', userId: APP.userId(), userName: APP.userName(), userFoto: currentUser.foto, msg: $.format.date(new Date(), 'dd.MM.yyyy HH:mm:ss')+': [watch] - unknown error - disable location-query ...'})
                navigator.geolocation.clearWatch APP._realPositionWatch
                APP._realPositionWatch = null
          , { enableHighAccuracy: true, maximumAge: VoyageX.Backend._POS_QUERY_INTERVAL_MILLIS, timeout: VoyageX.Backend._POS_QUERY_TIMEOUT_MILLIS }
      # alternative: poll position
      #APP._realPositionWatch = {active: true}
      #setTimeout 'APP._queryRealPosition()', VoyageX.Backend._POS_QUERY_INTERVAL_MILLIS
  
  _debugRealPositionCB: (position, mode) ->
    sBs = window.searchBounds APP._realPosition.lat, APP._realPosition.lng, APP._moveSensorDistMeters
    move = !window.withinSearchBounds position.coords.latitude, position.coords.longitude, sBs
    debugMsg = $.format.date(new Date(), 'dd.MM.yyyy HH:mm:ss')+': ['+mode+'] - move='+move+' - '+trimPosVal(position.coords.latitude)+'/'+trimPosVal(position.coords.longitude)
    #debugMsg += '\napp[lat|lng] = '+APP._realPosition.lat+' | '+APP._realPosition.lng
    #debugMsg += '\npos[lat|lng] = '+position.coords.latitude+' | '+position.coords.longitude
    APP._comm.send('/system', {type: 'debug', userId: APP.userId(), userName: APP.userName(), userFoto: currentUser.foto, msg: debugMsg})
    APP._setRealPosition position

  _debugWatchRealPosition: (position) ->
    APP._debugRealPositionCB position, 'watch'
  
  _debugPollRealPosition: (position) ->
    APP._debugRealPositionCB position, 'poll'

  # @deprecated -> navigator.geolocation.watchPosition
  _queryRealPosition: () ->
    unless APP._realPositionWatch? && APP._realPositionWatchactive
      return false
    navigator.geolocation.getCurrentPosition(APP._setRealPosition, (error) ->
        switch error.code
          when error.PERMISSION_DENIED
            console.log 'ERROR: user did not share geolocation data - disable location-query ...'
            APP._comm.send('/system', {type: 'error', userId: APP.userId(), userName: APP.userName(), userFoto: currentUser.foto, msg: $.format.date(new Date(), 'dd.MM.yyyy HH:mm:ss')+': [poll] - user did not share geolocation data - disable location-query ...'})
          when error.POSITION_UNAVAILABLE
            console.log 'WARN: could not detect current position - retry ...'
            APP._comm.send('/system', {type: 'error', userId: APP.userId(), userName: APP.userName(), userFoto: currentUser.foto, msg: $.format.date(new Date(), 'dd.MM.yyyy HH:mm:ss')+': [poll] - could not detect current position ...'})
            setTimeout 'APP._debugPollRealPosition({coords: {latitude: APP._realPosition.lat, longitude: APP._realPosition.lng}})', VoyageX.Backend._POS_QUERY_INTERVAL_MILLIS
          when error.TIMEOUT
            console.log 'WARN: query position timeout - retry ...'
            APP._comm.send('/system', {type: 'error', userId: APP.userId(), userName: APP.userName(), userFoto: currentUser.foto, msg: $.format.date(new Date(), 'dd.MM.yyyy HH:mm:ss')+': [poll] - query position timeout'})
            setTimeout 'APP._debugPollRealPosition({coords: {latitude: APP._realPosition.lat, longitude: APP._realPosition.lng}})', VoyageX.Backend._POS_QUERY_INTERVAL_MILLIS
          else
            console.log 'ERROR: unknown error - disable location-query ...'
            APP._comm.send('/system', {type: 'error', userId: APP.userId(), userName: APP.userName(), userFoto: currentUser.foto, msg: $.format.date(new Date(), 'dd.MM.yyyy HH:mm:ss')+': [poll] - unknown error - disable location-query ...'})
    , { enableHighAccuracy: true, maximumAge: VoyageX.Backend._POS_QUERY_INTERVAL_MILLIS, timeout: VoyageX.Backend._POS_QUERY_TIMEOUT_MILLIS })

  _systemCB: (message) ->
    console.log 'got a system - message: ' + message.type
    if message.type == 'ready_notification'
      systemInitCB()
      # subscribe to all channels stored in subscribeTo-buffer
      while (channelPath = subscribeTo.pop())
        i = channelPath.indexOf(VoyageX.PEER_CHANNEL_PREFIX)
        channel = (if i == -1 then channelPath else channelPath.substr(0, i)).substr(1)
        Comm.Comm.subscribeTo channelPath, Comm.Comm.channelCallBacksJSON[channel].callback # eval(channel+'CB')
    else if message.type == 'subscription_grant_request'
    else if message.type == 'subscription_granted'
      for channel in Main.commChannels()
        if channel == 'system'
          continue
        channelPath = '/'+channel
        unless VoyageX.USE_GLOBAL_SUBSCRIBE
          channelPath += VoyageX.PEER_CHANNEL_PREFIX+message.peer.channel_enc_key
        Comm.Comm.subscribeTo channelPath, Comm.Comm.channelCallBacksJSON[channel].callback # eval(channel+'CB')
    else if message.type == 'subscription_denied'
    else if message.type == 'subscription_grant_revoked'
      for channel in Main.commChannels()
        if channel == 'system'
          continue
        channelPath = '/'+channel
        unless VoyageX.USE_GLOBAL_SUBSCRIBE
          channelPath += VoyageX.PEER_CHANNEL_PREFIX+message.peer.channel_enc_key
        Comm.Comm.unsubscribeFrom channelPath
    else if message.type == 'quit_subscription'
      true # do nothing
    else if message.type == 'callback'
      if message.channel == 'uploads'
        delete message.channel
        #message.type = message.action
        #delete message.action
        APP._uploadsCB message
    APP._view._systemCB message
  
  _talkCB: (message) ->
    peer = APP.storage().getUser parseInt(message.userId)
    APP.storage().addChatMessage message.text, peer, message.type == 'p2p-message'
    delete message.userId
    message['peer'] = peer
    APP._view._talkCB message
  
  _uploadsCB: (upload) ->
    console.log 'got an uploads - message: ' + upload.type
    if upload.type == 'callback'
      # async backend response
      if upload.action? && upload.action == 'poi_sync'
        # assume that sync already performed with backend-response - here we hava after-commit-faye-callback
        currentUser.curCommitHash = upload.commit_hash
        #qPoiId = if upload.poi.local_time_secs? then -upload.poi.local_time_secs else upload.poi.id
        storedPoi = APP.storage().getPoi upload.poi.id
        callback = ((oldNotes) ->
            (cbPoi, cbNewNotes) ->
                #  
                # there could also be some new pois from other users! order might be mixed
                #
                location = APP.storage().getLocation(cbPoi.locationId)
                newNotes = oldNotes.slice 0, oldNotes.length-cbNewNotes.length
                for note, idx in cbNewNotes
                  newNotes.push note
                  if note.user?
                    note.userId = note.user.id
                    delete note.user
                  delete note.local_time_secs
                cbPoi.notes = newNotes
                VoyageX.TemplateHelper.openPOINotePopup cbPoi, null, true
                APP.view().scrollToPoiNote cbNewNotes[cbNewNotes.length-1].id
            )(storedPoi.notes)
        # save attachments from new other user's notes
        loadStats = { numAdded: upload.poi.notes.length, numLeft: upload.poi.notes.length }
        for note in upload.poi.notes
          Storage.Model.instance().syncWithStorage upload, callback, note, loadStats, note.local_time_secs?
    else if upload.type == 'poi_note_upload'
      unless upload.poi_note.user.id == APP.userId()
        # TODO: unify json-format, until then avoid circular structure
        poi = upload.poi_note.poi
        Storage.Model.setupPoiForNote poi
        msg = { poi: poi }
        Storage.Model.instance().syncWithStorage msg, VoyageX.View.addPoiNotes, upload.poi_note
        APP.view().alert()
    else if upload.type == 'poi_sync'
      if upload.poi.user.id != APP.userId()
        delete upload.poi.user
        poi = upload.poi
        Storage.Model.setupPoiForNote poi
        msg = { poi: poi }
        loadStats = { numAdded: poi.notes.length, numLeft: poi.notes.length }
        for note in poi.notes
          Storage.Model.instance().syncWithStorage msg, VoyageX.View.addPoiNotes, note, loadStats
        APP.view().alert()

  panPosition: (lat, lng, address) ->
    APP._setSelectedPositionLatLng Main.markerManager().get(), lat, lng, address
    APP.map().panTo([lat, lng])
    #APP.map().setView([lat, lng], 16)
    #VoyageX.NavBar.menuNavClick('map')

  # TODO: provide callback
  photoNav: () ->
#    selectedTab = $('#photo_nav_panel ul[role=tablist] [class~=ui-tabs-active]').attr('aria-controls')
#    switch selectedTab
#      when 'pois_preview'
    # pois have already been loaded - when map got initialized - and are updated with the syncer
    # @see _initPositionCB
    # BUT! notes have not been loaded maybe
    #sBs = Main.markerManager().searchBounds(VoyageX.SEARCH_RADIUS_METERS, this.map())
    pois = APP.storage().getPois (poi) ->
        sBs = window.searchBounds APP._selectedPosition.lat, APP._selectedPosition.lng, VoyageX.SEARCH_RADIUS_METERS
        if poi.lat >= sBs.lat_south && poi.lat <= sBs.lat_north &&
           poi.lng >= sBs.lng_west && poi.lng <= sBs.lng_east
#          unless poi.notes && poi.notes.length >= 1
          # dummy-poiNote for swiper - replaced when attachments are loaded
          unless poi.notes? && poi.notes.length >= 1
            poi.notes = [{id: -1, attachment: {url: VoyageX.IMAGES_SWIPER_LOADING_PATH, content_type: 'image/png', width: 200, height: 100}}]
          Storage.Model.instance().loadPoiNotes poi.id, null, (poiClone) ->
              swiperDummy = $('#poi_swiper_'+poi.id+' [data-poiNoteId=-1]')
              if swiperDummy.length >= 1
                # if there is a template ist must be swiper's loading-dummy
                swiperDummy.remove()
                for note in poiClone.notes
                  swiperSlideHtml = VoyageX.TemplateHelper.swiperSlideHtml poi, note
                  $('#poi_swiper_'+poi.id+' .swiper-wrapper').append(swiperSlideHtml)
                  mySwiper = window['myPoiSwiper'+poi.id]
                  mySwiper.reInit()
              else
                # template didn't insert swiperDummy yet, so we can use the real data
                poi.notes = poiClone.notes
          return true
        else
          return false
    this.view().previewPois pois
#      when 'location_bookmarks'
#        APP.model().photoNav @_selectedPosition.lat, @_selectedPosition.lng, (pois) ->
#            console.log('TODO: APP.photonav for location_bookmarks ...')
#      when 'people_of_interest'
#        APP.model().photoNav @_selectedPosition.lat, @_selectedPosition.lng, (pois) -> 
#            console.log('TODO: APP.photonav for people_of_interest ...')
#      else
#        alert('unknown photoNav-tab '+selectedTab)

  swiperPhotoClicked: (swiper) ->
    #$('#current_address').html($(swiper.clickedSlide).attr('data-address'))
    # test sync with using string instead of integer
    #APP.showPOI $(swiper.clickedSlide).attr('data-poiId'), $(swiper.clickedSlide).attr('data-poiNoteId')
    APP.showPOI parseInt($(swiper.clickedSlide).attr('data-poiId')), parseInt($(swiper.clickedSlide).attr('data-poiNoteId'))

  swiperPhotoChanged: (swiper) ->
    #$('#current_address').html($(swiper.activeSlide()).attr('data-address'))
    `;` 
  #  onSlideClick: APP.swiperPhotoClicked,
#  window.mySwiper = $('#upload_preview_swiper').swiper({
#    mode:'horizontal',
#    loop: false,
#    freeModeFluid: true,
#    #onSlideClick: APP.swiperPhotoClicked,
#    onSlideChangeEnd: photoChanged
#  })

  markerControls: () ->
    marker = Main.markerManager().get()
#    address = null
#    APP._setSelectedPositionLatLng marker, marker._latlng.lat, marker._latlng.lng, address
    VoyageX.TemplateHelper.openMarkerControlsPopup()

  poiNoteControls: () ->
    if isMobile()
      $('#open_upload_data_btn').click()
    else
      $('#upload_data_conrols').dialog('open')
      if ! $('#upload_data_conrols').parent().hasClass('seethrough_panel')
        $('#upload_data_conrols').parent().addClass('seethrough_panel')

  # sets up form
  poiNoteInput: () ->
    $('#poi_note_input').html('')
    VoyageX.TemplateHelper.poiNoteInputHtml('poi_note_input')
    APP.poiNoteControls()

  getUserMarker: (meta = false) ->
    markerMeta = Main.markerManager().forUser()
    if markerMeta?
      return if meta then markerMeta else markerMeta.target()
    null

  getMarker: (poi, meta = false) ->
    markerMeta = Main.markerManager().forPoi poi.id
    if markerMeta?
      return if meta then markerMeta else markerMeta.target()
    else
      if poi.location?
        return Main.markerManager().add poi.location, Main._markerEventsCB, null, meta
      else
        if poi.locationId?
          location = Comm.StorageController.instance().getLocation poi.locationId
        else
          location = {lat: poi.lat, lng: poi.lng, address: poi.address}
        return Main.markerManager().add location, Main._markerEventsCB, null, meta

  getPeerMarker: (peer, location, meta = false) ->
    markerMeta = Main.markerManager().forPeer peer.id
    if markerMeta?
      return if meta then markerMeta else markerMeta.target()
    else
      return Main.markerManager().add location, Main._markerEventsCB, {isUserMarker: false, peer: peer}, meta

  getOpenPopupMarker: (meta = false) ->
    if (userMarkerPopupPanel = $('#marker_controls')).length >= 1
      marker = Main.markerManager().get meta
    else if (peerMarkerPopupPanel = $('div[id^=peer_popup_]')).length >= 1
      peerId = parseInt peerMarkerPopupPanel.attr('id').match(/[0-9]+$/)[0]
      #peer = Comm.StorageController.instance().getUser peerId
      marker = APP.getPeerMarker {id: peerId}, null, meta
    else
      if (poiMarkerPopupPanel = $('#poi_notes_container')).length >= 1
        poiId = parseInt poiMarkerPopupPanel.attr('data-poiId')
        marker = APP.getMarker {id: poiId}, meta
      else
        marker = null
    marker

  # just closes markers of specified type - not any other
  # poi_notes_container | marker_controls | peer_popup_{peer_id}
  preTogglePopup: () ->
    openPopupMarkerMeta = this.getOpenPopupMarker true
    if openPopupMarkerMeta?
      if openPopupMarkerMeta.target().getPopup()? && openPopupMarkerMeta.target().getPopup()._isOpen
        if openPopupMarkerMeta.isUserMarker
          Main._checkSaveNote 'marker_controls'
        else if openPopupMarkerMeta.peer?
          Main._checkSaveNote 'peer_popup_'+openPopupMarkerMeta.peer.id
        else
          Main._checkSaveNote 'poi_notes_container'
        openPopupMarkerMeta.target().closePopup()

  @closePopupCB: (leafletMarker) ->
    (event) ->
        meta = Main.markerManager().meta leafletMarker
        if meta.isUserMarker
          contentId = 'marker_controls'
        else if meta.peer?
          contentId = 'peer_popup_'+meta.peer.id
        else
          contentId = 'poi_notes_container'
        console.log('closePopupCB: contentId = '+contentId+', leafletMarker = '+Main.markerManager().toString(leafletMarker, meta))
        Main._checkSaveNote contentId
        Main.markerManager().userMarkerMouseOver true

  # poi_notes_container | marker_controls | peer_popup_{peer_id}
  @_checkSaveNote: (contentId) ->
    noteEditor = $('#'+contentId).parent().find('.note_editor').first()
    textArea = noteEditor.find('textarea')
    if textArea.length >= 1
      targetId = parseInt textArea.attr('id').match(/[0-9]+$/)[0]
      if contentId.match(/^peer_popup_/)?
        targetType = 'peer'
        console.log('_checkSaveNote: saving note for peer '+Comm.StorageController.instance().getUser(targetId).username)
      else
        targetType = 'bookmark'
        console.log('_checkSaveNote: saving note for location '+Comm.StorageController.instance().getLocation(targetId).address)
      Storage.Model.instance().addNote targetType, targetId, textArea.val()

  @_markerEventsCB: (event) ->
    address = null
    switch event.type
      when 'click'
        markerMeta = Main.markerManager().meta event.target
        if markerMeta.isUserMarker
          unless Main.markerManager().userMarkerMouseOver()
            # click on user-marker while poi-marker is open
            APP.preTogglePopup()
            Main.markerManager().userMarkerMouseOver true 
            APP.markerControls()
        else
        #unless markerMeta.isUserMarker
          APP.preTogglePopup()
          if event.target.getPopup() && event.target.getPopup()._isOpen
            # click on poi-marker with open popup
            event.target.closePopup()
            Main.markerManager().userMarkerMouseOver true
          else
            # click on poi-marker with no popup
            if markerMeta.peer?
              VoyageX.TemplateHelper.openPeerPopup markerMeta.peer, event.target
            else
              Storage.Model.instance().loadPoiNotes markerMeta.poi.id, null, (poi) ->
                  # userMarkerMouseOver is set in openPOINotePopup
                  VoyageX.TemplateHelper.openPOINotePopup poi, event.target
      when 'mouseover'
        markerMeta = Main.markerManager().meta event.target
        if markerMeta.isUserMarker && Main.markerManager().userMarkerMouseOver()
          unless event.target.getPopup() && event.target.getPopup()._isOpen
            # click on user-marker with no popup
            APP.preTogglePopup()
            APP.markerControls()
      when 'dblclick'
        APP._setSelectedPositionLatLng event.target, event.target._latlng.lat, event.target._latlng.lng, address
        APP.poiNoteInput()
      else
        APP._setSelectedPositionLatLng event.target, event.target._latlng.lat, event.target._latlng.lng, address
        APP.publishPosition()

#  backend: () ->
#    Main._BACKEND

  @commChannels: () ->
    Main._COMM_CHANNELS.slice(0)

  storage: () ->
    Main._STORAGE_CONTROLLER

  @mapControl: () ->
    Main._MAP_CONTROL

  map: () ->
    Main._MAP_CONTROL.map()

  @markerManager: () ->
    Main._MARKER_MANAGER

  markers: () ->
    Main._MARKER_MANAGER

  chat: () ->
    Main._CHAT_CONTROL

  model: () ->
    Main._STORAGE_MODEL

  view: () ->
    @_view

  transfer: () ->
    Main._UPLOAD_HELPER

  @instance: () ->
    Main._SINGLETON
